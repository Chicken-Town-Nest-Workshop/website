[{"title":"小雞鎮有兩篇新文章","type":0,"sectionRef":"#","url":"/blog/exceptionFilterAndCliCMD","content":"","keywords":"","version":null},{"title":"Nest CLI 常用指令​","type":1,"pageTitle":"小雞鎮有兩篇新文章","url":"/blog/exceptionFilterAndCliCMD#nest-cli-常用指令","content":"記錄了常用的 CLI 指令 前往觀看文章... ","version":null,"tagName":"h2"},{"title":"Exception filter​","type":1,"pageTitle":"小雞鎮有兩篇新文章","url":"/blog/exceptionFilterAndCliCMD#exception-filter","content":"Exception filter 用來攔截 throw 的例外訊息， 並將訊息做處理之後再回傳給客戶端 前往觀看文章... ","version":null,"tagName":"h2"},{"title":"小雞鎮祝大家有個美好的周末​","type":1,"pageTitle":"小雞鎮有兩篇新文章","url":"/blog/exceptionFilterAndCliCMD#小雞鎮祝大家有個美好的周末","content":"","version":null,"tagName":"h2"},{"title":"date time 踩雷小故事","type":0,"sectionRef":"#","url":"/blog/date time 踩雷小故事","content":"","keywords":"","version":null},{"title":"踩雷經過​","type":1,"pageTitle":"date time 踩雷小故事","url":"/blog/date time 踩雷小故事#踩雷經過","content":"各位鎮民們，事情是這樣子的，為了給大家有良好的守時觀念，所以小鎮決定先做好時間模組，但是在時間模組開發的過程中呢，踩到了一個地雷。 最一開始在 controller 回傳了 Date 物件但在 sagger 上顯示越看越不對勁，發現它顯示的是格林威治時間  @Get() getTownDateTime(): Date { const date = this.clockService.getDateTime(); return date; }  在副鎮長的協助下終於得到幾個結論 直接回傳 Date 的話，會被當成一個新的物件回傳前須要將她轉為字串或數字字串: 使用的是 ISO string數字: 使用的是 unix time 最終小雞鎮在這邊選擇了 ISO string  /** * 取得 +8 時間 */ getDateTime(): string { const offset = 8 * 60; // 8小時的分鐘數 const utcTime = this.getTimeZone().getTime(); // 使用 getTimeZone() 取得標準時間 const localTime = new Date(utcTime + offset * 60 * 1000); return localTime.toISOString(); }  ","version":null,"tagName":"h2"},{"title":"小雞鎮在這邊預祝大家中秋節快樂​","type":1,"pageTitle":"date time 踩雷小故事","url":"/blog/date time 踩雷小故事#小雞鎮在這邊預祝大家中秋節快樂","content":"小雞鎮時間模組上線嚕 ","version":null,"tagName":"h2"},{"title":"小雞鎮文章更新了","type":0,"sectionRef":"#","url":"/blog/nestJsCrudAndAutoLoad","content":"","keywords":"","version":null},{"title":"Entity Auto Load​","type":1,"pageTitle":"小雞鎮文章更新了","url":"/blog/nestJsCrudAndAutoLoad#entity-auto-load","content":"TypeORM 有兩種模式 自動載入: TypeORM 會自動搜尋需要註冊的檔案手動載入: 須由開發者決定應該要載入那些 Entity 前往觀看文章... ","version":null,"tagName":"h2"},{"title":"TypeORM 的 CRUD​","type":1,"pageTitle":"小雞鎮文章更新了","url":"/blog/nestJsCrudAndAutoLoad#typeorm-的-crud","content":"在整個 TypeORM 最核心的觀念就是 CRUD CRUD 則是一個縮寫，代表了以下四個基本操作： Create (新增)：在資料庫中新增記錄或資料Read (讀取)：從資料庫中讀取或搜尋記錄或資料Update (更新)：更新現有記錄或資料的內容Delete (刪除)：從資料庫中刪除現有的記錄或資料 前往觀看文章... ","version":null,"tagName":"h2"},{"title":"小雞鎮呼籲大家颱風天沒事盡量別出門​","type":1,"pageTitle":"小雞鎮文章更新了","url":"/blog/nestJsCrudAndAutoLoad#小雞鎮呼籲大家颱風天沒事盡量別出門","content":"","version":null,"tagName":"h2"},{"title":"小雞鎮文章更新了","type":0,"sectionRef":"#","url":"/blog/nestJsLifecycle","content":"","keywords":"","version":null},{"title":"Nest js 生命週期​","type":1,"pageTitle":"小雞鎮文章更新了","url":"/blog/nestJsLifecycle#nest-js-生命週期","content":"","version":null,"tagName":"h2"},{"title":"主程式生命週期​","type":1,"pageTitle":"小雞鎮文章更新了","url":"/blog/nestJsLifecycle#主程式生命週期","content":"","version":null,"tagName":"h3"},{"title":"Runtime 生命週期​","type":1,"pageTitle":"小雞鎮文章更新了","url":"/blog/nestJsLifecycle#runtime-生命週期","content":"前往觀看文章... ","version":null,"tagName":"h3"},{"title":"小雞鎮祝大家有個美好的一周​","type":1,"pageTitle":"小雞鎮文章更新了","url":"/blog/nestJsLifecycle#小雞鎮祝大家有個美好的一周","content":"","version":null,"tagName":"h2"},{"title":"來聽副鎮長的演唱會","type":0,"sectionRef":"#","url":"/blog/nestJsWorkshopLifecycle","content":"","keywords":"","version":null},{"title":"簡報​","type":1,"pageTitle":"來聽副鎮長的演唱會","url":"/blog/nestJsWorkshopLifecycle#簡報","content":" 前往觀看完整簡報... ","version":null,"tagName":"h2"},{"title":"範例 GitHub​","type":1,"pageTitle":"來聽副鎮長的演唱會","url":"/blog/nestJsWorkshopLifecycle#範例-github","content":"This is nestjs request sample for test request lifecycle 前往觀看完整程式碼... ","version":null,"tagName":"h2"},{"title":"小雞鎮趕快來聽副鎮長的演唱會​","type":1,"pageTitle":"來聽副鎮長的演唱會","url":"/blog/nestJsWorkshopLifecycle#小雞鎮趕快來聽副鎮長的演唱會","content":"","version":null,"tagName":"h2"},{"title":"nest 模板上線嚕!","type":0,"sectionRef":"#","url":"/blog/nest 模板","content":"","keywords":"","version":null},{"title":"模板內容​","type":1,"pageTitle":"nest 模板上線嚕!","url":"/blog/nest 模板#模板內容","content":"swaggerdockerfile ","version":null,"tagName":"h2"},{"title":"使用方式​","type":1,"pageTitle":"nest 模板上線嚕!","url":"/blog/nest 模板#使用方式","content":"","version":null,"tagName":"h2"},{"title":"下載​","type":1,"pageTitle":"nest 模板上線嚕!","url":"/blog/nest 模板#下載","content":"載點 code &gt; download Zip解壓縮 ","version":null,"tagName":"h3"},{"title":"模板使用方式​","type":1,"pageTitle":"nest 模板上線嚕!","url":"/blog/nest 模板#模板使用方式","content":"修改專案名稱於 package.js 修改 name { &quot;name&quot;: &quot;[專案名稱]&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;description&quot;: &quot;&quot;, &quot;author&quot;: &quot;&quot;, &quot;private&quot;: true, &quot;license&quot;: &quot;UNLICENSED&quot;, &quot;scripts&quot;: { &quot;build&quot;: &quot;nest build&quot;, -- 下略 --  安裝依賴 pnpm i  啟動 pnpm start  開啟: http://localhost:3055/api ","version":null,"tagName":"h3"},{"title":"docker​","type":1,"pageTitle":"nest 模板上線嚕!","url":"/blog/nest 模板#docker","content":"","version":null,"tagName":"h2"},{"title":"建立 image​","type":1,"pageTitle":"nest 模板上線嚕!","url":"/blog/nest 模板#建立-image","content":"docker build --pull --rm -f &quot;.dockerfile&quot; -t [image name]:[version] .  ","version":null,"tagName":"h3"},{"title":"run image​","type":1,"pageTitle":"nest 模板上線嚕!","url":"/blog/nest 模板#run-image","content":"docker run --name nest-app -p 3055:3055 [image name]:[version]  開啟: http://localhost:3055/api ","version":null,"tagName":"h3"},{"title":"小雞鎮在這邊祝福大家有美好的一天​","type":1,"pageTitle":"nest 模板上線嚕!","url":"/blog/nest 模板#小雞鎮在這邊祝福大家有美好的一天","content":"","version":null,"tagName":"h2"},{"title":"副鎮長上任啦!","type":0,"sectionRef":"#","url":"/blog/副鎮長上任","content":"今天終於有副鎮長上任啦! 副鎮長宣言: 河河河河河河","keywords":"","version":null},{"title":"圖書館館長上任啦!","type":0,"sectionRef":"#","url":"/blog/新圖書館館長","content":"圖書館館長上任啦! 圖書館館長宣言: 可爽了","keywords":"","version":null},{"title":"今天是小雞鎮的生日","type":0,"sectionRef":"#","url":"/blog/小雞鎮誕生","content":"","keywords":"","version":null},{"title":"鎮長宣言​","type":1,"pageTitle":"今天是小雞鎮的生日","url":"/blog/小雞鎮誕生#鎮長宣言","content":"小雞鎮最大的宗旨就是，希望大家可以快快樂樂的學 Nest 努力讓小鎮的版圖逐漸擴大 ","version":null,"tagName":"h2"},{"title":"小鎮目標​","type":1,"pageTitle":"今天是小雞鎮的生日","url":"/blog/小雞鎮誕生#小鎮目標","content":"提供 Nest 的技術文件 並且以小鎮裡的各個建設，來做中學 Nest 的模組運用 ","version":null,"tagName":"h2"},{"title":"🏘️ 小雞鎮","type":0,"sectionRef":"#","url":"/docs/intro","content":"","keywords":"","version":"Next"},{"title":"歡迎光臨小雞鎮​","type":1,"pageTitle":"🏘️ 小雞鎮","url":"/docs/intro#歡迎光臨小雞鎮","content":"小雞鎮誕生於 2023/9/26 ","version":"Next","tagName":"h2"},{"title":"小雞鎮的願景​","type":1,"pageTitle":"🏘️ 小雞鎮","url":"/docs/intro#小雞鎮的願景","content":"在小雞鎮的一個普通的早晨，太陽剛剛升起，照亮了這個寧靜的小鎮，小雞鎮是一個位於鄉間的小鎮，以其獨特的三大主題而聞名 首先有一個熙熙攘攘的地方，那就是小雞鎮的Nest JS工作坊 這個工作坊是一個聚集了技術愛好者和開發者的地方，他們經常舉辦各種技術研討會和工作坊，分享最新的Nest JS技術和心得， 每當有新的技術文章上架時，整個小鎮都會為之振奮，因為這些文章為他們帶來了無窮的知識和靈感 其次小雞鎮的造鎮計畫讓這個地方更加特別 這個計畫的目標是將小雞鎮打造成一個擁有各種各樣店鋪的繁華小鎮，每一家店都是一個獨特的模組，提供不同的商品和服務。這個計畫已經吸引了許多創業家和店主，他們紛紛在小鎮開設了各種各樣的店鋪，從咖啡館到手工藝品店應有盡有，小雞鎮的居民以及遠道而來的遊客都享受著這個多姿多彩的小鎮 最後小鎮新聞是小雞鎮居民的重要信息來源 每當小鎮有重大消息時，如一家新店開業、一個特別活動即將舉行或是技術工作坊的通知，都會在小鎮新聞上發布，這份新聞不僅是居民生活的一部分，還是讓他們保持聯繫的橋樑 總之小雞鎮雖然小巧，卻因其三大主題而充滿活力。這個小鎮不僅是技術的樂園，也是一個充滿創意和多樣性的社區。無論是居民還是遊客，每個人都能在這個特別的小鎮找到自己的位置，共同參與這個獨特的生活方式 ","version":"Next","tagName":"h2"},{"title":"🐔 安裝 Swagger","type":0,"sectionRef":"#","url":"/docs/nest/addSwagger","content":"","keywords":"","version":"Next"},{"title":"步驟​","type":1,"pageTitle":"🐔 安裝 Swagger","url":"/docs/nest/addSwagger#步驟","content":"","version":"Next","tagName":"h2"},{"title":"安裝​","type":1,"pageTitle":"🐔 安裝 Swagger","url":"/docs/nest/addSwagger#安裝","content":"pnpm install --save @nestjs/swagger  ","version":"Next","tagName":"h3"},{"title":"Bootstrap 設定​","type":1,"pageTitle":"🐔 安裝 Swagger","url":"/docs/nest/addSwagger#bootstrap-設定","content":"import { NestFactory } from '@nestjs/core'; import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger'; //swagger import { AppModule } from './app.module'; async function bootstrap() { const app = await NestFactory.create(AppModule); // [B] swagger const config = new DocumentBuilder() .setTitle('Car API') .setDescription('The Car API description') .setVersion('1.0') .addTag('Car') .build(); const document = SwaggerModule.createDocument(app, config); SwaggerModule.setup('api', app, document); // [E] swagger await app.listen(3050); } bootstrap();  ","version":"Next","tagName":"h3"},{"title":"啟動​","type":1,"pageTitle":"🐔 安裝 Swagger","url":"/docs/nest/addSwagger#啟動","content":"pnpm start  http://localhost:3050/api ","version":"Next","tagName":"h3"},{"title":"🐔 關於 NestJS","type":0,"sectionRef":"#","url":"/docs/nest/about","content":"","keywords":"","version":"Next"},{"title":"語言​","type":1,"pageTitle":"🐔 關於 NestJS","url":"/docs/nest/about#語言","content":"在 NestJS 框架底下，我們將使用 TypeScript 來做為主要編寫的語言 ","version":"Next","tagName":"h2"},{"title":"環境​","type":1,"pageTitle":"🐔 關於 NestJS","url":"/docs/nest/about#環境","content":"安裝 Node (&gt;= 16) nvm 安裝NestJS CLI # 安裝 CLI npm i -g @nestjs/cli  ","version":"Next","tagName":"h2"},{"title":"建立專案​","type":1,"pageTitle":"🐔 關於 NestJS","url":"/docs/nest/about#建立專案","content":"","version":"Next","tagName":"h2"},{"title":"建立​","type":1,"pageTitle":"🐔 關於 NestJS","url":"/docs/nest/about#建立","content":"# 建立專案 nest new [project-name]  ","version":"Next","tagName":"h3"},{"title":"使用 TypeScript 功能​","type":1,"pageTitle":"🐔 關於 NestJS","url":"/docs/nest/about#使用-typescript-功能","content":"# 建立專案 nest new [project-name] --strict  ","version":"Next","tagName":"h3"},{"title":"建立公用 lib​","type":1,"pageTitle":"🐔 關於 NestJS","url":"/docs/nest/about#建立公用-lib","content":"# 建立專案 cd [project-name]; nest g lib ${library-name}  ","version":"Next","tagName":"h3"},{"title":"專案架構​","type":1,"pageTitle":"🐔 關於 NestJS","url":"/docs/nest/about#專案架構","content":"","version":"Next","tagName":"h2"},{"title":"目錄結構​","type":1,"pageTitle":"🐔 關於 NestJS","url":"/docs/nest/about#目錄結構","content":"src └─app.controller.spec.ts │ └─app.controller.ts │ └─app.module.ts │ └─app.service.ts │ └─main.ts  ","version":"Next","tagName":"h3"},{"title":"檔案說明​","type":1,"pageTitle":"🐔 關於 NestJS","url":"/docs/nest/about#檔案說明","content":"檔案\t描述app.controller.ts\t具有單一路由的基本控制器 app.controller.spec.ts\t控制器的單元測試 app.module.ts\t應用程式的根模組 app.service.ts\t具有單一方法的基本服務 main.ts\t應用程式的入口檔案，使用核心函數 NestFactory 創建一個 Nest 應用程式實例 ","version":"Next","tagName":"h3"},{"title":"main.ts​","type":1,"pageTitle":"🐔 關於 NestJS","url":"/docs/nest/about#maints","content":"import { NestFactory } from '@nestjs/core'; import { AppModule } from './app.module'; async function bootstrap() { const app = await NestFactory.create(AppModule); await app.listen(3000); } bootstrap();  可切換底層框架為 express 或 fastify 切換為 express import { NestFactory } from '@nestjs/core'; import { AppModule } from './app.module'; async function bootstrap() { const app = await NestFactory.create&lt;NestExpressApplication&gt;(AppModule); await app.listen(3000); } bootstrap();  切換為 fastify import { NestFactory } from '@nestjs/core'; import { AppModule } from './app.module'; async function bootstrap() { const app = await NestFactory.create&lt;NestFastifyApplication&gt;(AppModule); await app.listen(3000); } bootstrap();  ","version":"Next","tagName":"h3"},{"title":"Nest js 生命週期​","type":1,"pageTitle":"🐔 關於 NestJS","url":"/docs/nest/about#nest-js-生命週期","content":"","version":"Next","tagName":"h2"},{"title":"主程式生命週期​","type":1,"pageTitle":"🐔 關於 NestJS","url":"/docs/nest/about#主程式生命週期","content":"","version":"Next","tagName":"h3"},{"title":"Runtime 生命週期​","type":1,"pageTitle":"🐔 關於 NestJS","url":"/docs/nest/about#runtime-生命週期","content":" ","version":"Next","tagName":"h3"},{"title":"REF​","type":1,"pageTitle":"🐔 關於 NestJS","url":"/docs/nest/about#ref","content":"NestJS 官網 梁大哥 教學 ","version":"Next","tagName":"h2"},{"title":"🐔 將 Service 抽象化","type":0,"sectionRef":"#","url":"/docs/nest/cerateServiceInterface","content":"","keywords":"","version":"Next"},{"title":"關於抽象化​","type":1,"pageTitle":"🐔 將 Service 抽象化","url":"/docs/nest/cerateServiceInterface#關於抽象化","content":"會進行抽象化的幾個主要原因 進行單元測試前，需要做資料隔離符合介面隔離原則讓模組之間的耦合度降低，確保後續的維護與修改可以更容易的進行符合依賴反轉原則讓其他呼叫者，依賴抽象，而不要依賴細節 通常開發過程會先定義interface，在實作細節 ","version":"Next","tagName":"h2"},{"title":"Service 抽象化​","type":1,"pageTitle":"🐔 將 Service 抽象化","url":"/docs/nest/cerateServiceInterface#service-抽象化","content":"目前專案結構 src └─user │ └─app.controller.spec.ts │ └─app.controller.ts │ └─app.module.ts │ └─app.service.ts │ └─main.ts  ","version":"Next","tagName":"h2"},{"title":"建立 interface​","type":1,"pageTitle":"🐔 將 Service 抽象化","url":"/docs/nest/cerateServiceInterface#建立-interface","content":"在 user 資料夾底下，建立一個 interfaces 的資料夾並在裡面建立一個 user.service.interface.ts 的檔案 user └─dto │ └─create-user.dto.ts │ │ │ └─update-user.dto.ts │ │ │ └─user.dto.ts │ │ │ └─index.ts │ └─interface │ └─user.service.interface.ts │ └─user.controller.ts │ └─user.service.ts │ └─user.module.ts  定義 user.service 所要開放的介面 import { UpdateUserDto, CreateUserDto, UserDto } from '../dto'; export interface UserServiceInterface { /** 使用 store id 查出底下所有的使用者 * * @param storeId store id * @returns user list */ getUserByStoreId(storeId: string): Promise&lt;Array&lt;UserDto&gt;&gt;; /** 使用 user id 查詢使用者 * * @param id user id * @returns user */ getUserById(id: string): Promise&lt;UserDto&gt;; /** 新增使用者 * * @param newUser new user * @param userId update user id * @returns new user list */ createUser(newUser: CreateUserDto, userId: string): Promise&lt;Array&lt;UserDto&gt;&gt;; /**更新使用者 * * @param id user id * @param oldUser edit user * @param userId update user id * @returns user list */ updaterUser( id: string, oldUser: UpdateUserDto, userId: string, ): Promise&lt;Array&lt;UserDto&gt;&gt;; /**刪除使用者 * * @param id user id * @returns user list */ deleteUser(id: string): Promise&lt;Array&lt;UserDto&gt;&gt;; }  ","version":"Next","tagName":"h3"},{"title":"繼承並實作介面​","type":1,"pageTitle":"🐔 將 Service 抽象化","url":"/docs/nest/cerateServiceInterface#繼承並實作介面","content":"於 user.service.ts 繼承介面，並且實作細節 user └─dto │ └─create-user.dto.ts │ │ │ └─update-user.dto.ts │ │ │ └─user.dto.ts │ │ │ └─index.ts │ └─interface │ └─user.service.interface.ts │ └─user.controller.ts │ └─user.service.ts │ └─user.module.ts  export class UserService implements UserServiceInterface 使用implements來繼承介面並實作 import { Injectable } from '@nestjs/common'; import { UserServiceInterface } from './interfaces/user.service.interface'; import { UpdateUserDto, CreateUserDto, UserDto } from './dto'; @Injectable() export class UserService implements UserServiceInterface { /** 使用 store id 查出底下所有的使用者 * * @param storeId store id * @returns user list */ async getUserByStoreId(storeId: string): Promise&lt;Array&lt;UserDto&gt;&gt; { let users = new Array&lt;UserDto&gt;(); users.push({ id: 'f7541155-a4ff-4ca2-bfc5-a82ad98e2e86', fullName: 'Big Pig', email: 'BigPig@local.com', phoneNumber: '0900000000', userName: 'pig pig', }); users.push({ id: '80f78f75-37b5-4977-bffc-5afc5db99123', fullName: 'Pink Chicken', email: 'PinkChicken@local.com', phoneNumber: '0900000011', userName: 'Hi Chicken', }); return users; } /** 使用 user id 查詢使用者 * * @param id user id * @returns user */ async getUserById(id: string): Promise&lt;UserDto&gt; { let user: UserDto = { id: '80f78f75-37b5-4977-bffc-5afc5db99123', fullName: 'Pink Chicken', email: 'PinkChicken@local.com', phoneNumber: '0900000011', userName: 'Hi Chicken', }; return user; } /** 新增使用者 * * @param newUser new user * @param userId update user id * @returns new user list */ async createUser( newUser: CreateUserDto, userId: string, ): Promise&lt;Array&lt;UserDto&gt;&gt; { let users = new Array&lt;UserDto&gt;(); users.push({ id: '591afd77-32d0-44c2-a487-b6bd8850a0fe', fullName: newUser.fullName, email: newUser.email, phoneNumber: newUser.phoneNumber, userName: newUser.userName, }); users.push({ id: 'f7541155-a4ff-4ca2-bfc5-a82ad98e2e86', fullName: 'Big Pig', email: 'BigPig@local.com', phoneNumber: '0900000000', userName: 'pig pig', }); users.push({ id: '80f78f75-37b5-4977-bffc-5afc5db99123', fullName: 'Pink Chicken', email: 'PinkChicken@local.com', phoneNumber: '0900000011', userName: 'Hi Chicken', }); return users; } /**更新使用者 * * @param id user id * @param oldUser edit user * @param userId update user id * @returns user list */ async updaterUser( id: string, oldUser: UpdateUserDto, userId: string, ): Promise&lt;Array&lt;UserDto&gt;&gt; { let users = new Array&lt;UserDto&gt;(); users.push({ id: 'f7541155-a4ff-4ca2-bfc5-a82ad98e2e86', fullName: oldUser.fullName, email: oldUser.email, phoneNumber: oldUser.phoneNumber, userName: oldUser.fullName, }); users.push({ id: '80f78f75-37b5-4977-bffc-5afc5db99123', fullName: 'Pink Chicken', email: 'PinkChicken@local.com', phoneNumber: '0900000011', userName: 'Hi Chicken', }); return users; } /**刪除使用者 * * @param id user id * @returns user list */ async deleteUser(id: string): Promise&lt;Array&lt;UserDto&gt;&gt; { let users = new Array&lt;UserDto&gt;(); users.push({ id: '80f78f75-37b5-4977-bffc-5afc5db99123', fullName: 'Pink Chicken', email: 'PinkChicken@local.com', phoneNumber: '0900000011', userName: 'Hi Chicken', }); return users; } }  ","version":"Next","tagName":"h3"},{"title":"將服務註冊到 module​","type":1,"pageTitle":"🐔 將 Service 抽象化","url":"/docs/nest/cerateServiceInterface#將服務註冊到-module","content":"到 user.module.ts 註冊服務 user └─dto │ └─create-user.dto.ts │ │ │ └─update-user.dto.ts │ │ │ └─user.dto.ts │ │ │ └─index.ts │ └─interface │ └─user.service.interface.ts │ └─user.controller.ts │ └─user.service.ts │ └─user.module.ts  import { Module } from '@nestjs/common'; import { UserController } from './user.controller'; import { UserService } from './user.service'; @Module({ controllers: [UserController], providers: [ { provide: 'UserServiceInterface', // 注入時 tag 的標籤 useClass: UserService, // 服務的實體 }, ], }) export class UserModule {}  ","version":"Next","tagName":"h3"},{"title":"依賴反轉​","type":1,"pageTitle":"🐔 將 Service 抽象化","url":"/docs/nest/cerateServiceInterface#依賴反轉","content":"","version":"Next","tagName":"h2"},{"title":"在 Controller 依賴抽象​","type":1,"pageTitle":"🐔 將 Service 抽象化","url":"/docs/nest/cerateServiceInterface#在-controller-依賴抽象","content":"以下是修改前的程式碼， controller 是直接依賴 UserService 的實體 @Controller('user') export class UserController { constructor(private readonly userService: UserService) {} }  修改後，會變成 controller 依賴的是 UserServiceInterface 這介面 在透過注入時，module 來告訴 controller 真正應該使用哪個實體 @Controller('user') export class UserController { constructor( @Inject('UserServiceInterface') private readonly userService: UserServiceInterface, ) {} }   ","version":"Next","tagName":"h3"},{"title":"完整 controller 程式碼​","type":1,"pageTitle":"🐔 將 Service 抽象化","url":"/docs/nest/cerateServiceInterface#完整-controller-程式碼","content":"import { Controller, Get, Post, Body, Put, Param, Delete, Inject, } from '@nestjs/common'; import { UpdateUserDto, CreateUserDto, UserDto } from './dto'; import { UserServiceInterface } from './interfaces/user.service.interface'; @Controller('user') export class UserController { constructor( @Inject('UserServiceInterface') private readonly userService: UserServiceInterface, ) {} @Get(':storeId') async findAll(@Param('id') storeId: string): Promise&lt;Array&lt;UserDto&gt;&gt; { return await this.userService.getUserByStoreId(storeId); } @Get(':id') async findOne(@Param('id') id: string): Promise&lt;UserDto&gt; { return await this.userService.getUserById(id); } @Post() async create(@Body() createCatDto: CreateUserDto) { return await this.userService.createUser(createCatDto, ''); } @Put(':id') async update(@Param('id') id: string, @Body() updateCatDto: UpdateUserDto) { return await this.userService.updaterUser(id, updateCatDto, ''); } @Delete(':id') async remove(@Param('id') id: string) { return await this.userService.deleteUser(id); } }   Ref 梁大哥 github ","version":"Next","tagName":"h3"},{"title":"🐔 建立一個新的模組","type":0,"sectionRef":"#","url":"/docs/nest/createModul","content":"","keywords":"","version":"Next"},{"title":"目錄結構​","type":1,"pageTitle":"🐔 建立一個新的模組","url":"/docs/nest/createModul#目錄結構","content":"","version":"Next","tagName":"h2"},{"title":"新專案目錄結構​","type":1,"pageTitle":"🐔 建立一個新的模組","url":"/docs/nest/createModul#新專案目錄結構","content":"src └─app.controller.spec.ts │ └─app.controller.ts │ └─app.module.ts │ └─app.service.ts │ └─main.ts  ","version":"Next","tagName":"h3"},{"title":"建立資料夾​","type":1,"pageTitle":"🐔 建立一個新的模組","url":"/docs/nest/createModul#建立資料夾","content":"先建立一個 user 的資料夾 src └─user │ └─app.controller.spec.ts │ └─app.controller.ts │ └─app.module.ts │ └─app.service.ts │ └─main.ts  ","version":"Next","tagName":"h3"},{"title":"建立 Dto​","type":1,"pageTitle":"🐔 建立一個新的模組","url":"/docs/nest/createModul#建立-dto","content":"Dto 的全名為 data transfer object 定義資料傳輸時會使用的物件 注意: Dto != Entity 先定義一個使用者的 Dto 需將每個屬性加上 @ApiProperty() 這樣 swagger 才會顯示 並且可以針對 data 進行描述與限制 建立一個 dto 的目錄，並且建立一個 create-user.dto.ts 的檔案 user └─dto └─create-user.dto.ts  import { ApiProperty } from '@nestjs/swagger'; export class CreateUserDto { @ApiProperty({ description: '使用者全名', }) fullName: string; @ApiProperty({ description: 'user email', }) email: string; @ApiProperty({ description: 'user password', }) password: string; @ApiProperty({ description: '電話號碼', }) phoneNumber: string; @ApiProperty({ description: '使用者名稱', }) userName: string; }  建立一個 update-user.dto.ts 的檔案 user └─dto └─create-user.dto.ts │ └─update-user.dto.ts  import { ApiProperty } from '@nestjs/swagger'; export class UpdateUserDto { @ApiProperty({ description: 'user id', }) id: string; @ApiProperty({ description: '使用者全名', }) fullName: string; @ApiProperty({ description: 'user email', }) email: string; @ApiProperty({ description: '電話號碼', }) phoneNumber: string; @ApiProperty({ description: '使用者名稱', }) userName: string; }  建立一個 user.dto.ts user └─dto └─create-user.dto.ts │ └─update-user.dto.ts │ └─user.dto.ts │ └─index.ts  import { ApiProperty } from &quot;@nestjs/swagger&quot;; export class UserDto { @ApiProperty({ description: 'user id', }) id: string; @ApiProperty({ description: '使用者全名', }) fullName: string; @ApiProperty({ description: 'user email', }) email: string; @ApiProperty({ description: '電話號碼', }) phoneNumber: string; @ApiProperty({ description: '使用者名稱', }) userName: string; }  建立一個 index.ts 統一將 class 往上層拋 user └─dto └─create-user.dto.ts │ └─update-user.dto.ts │ └─user.dto.ts │ └─index.ts  export * from &quot;./create-user.dto&quot; export * from &quot;./update-user.dto&quot; export * from &quot;./user.dto&quot;  ","version":"Next","tagName":"h3"},{"title":"建立 Service​","type":1,"pageTitle":"🐔 建立一個新的模組","url":"/docs/nest/createModul#建立-service","content":"主要為商業邏輯層 所有的業務邏輯都應該集中在這一層 建立 user.service.ts user └─dto │ └─create-user.dto.ts │ │ │ └─update-user.dto.ts │ │ │ └─uer.dto.ts │ │ │ └─index.ts │ └─user.service.ts  import { Injectable } from '@nestjs/common'; import { UpdateUserDto, CreateUserDto, UserDto } from './dto'; @Injectable() export class UserService { /** 使用 store id 查出底下所有的使用者 * * @param storeId store id * @returns user list */ async getUserByStoreId(storeId: string): Promise&lt;Array&lt;UserDto&gt;&gt; { let users = new Array&lt;UserDto&gt;(); users.push({ id: 'f7541155-a4ff-4ca2-bfc5-a82ad98e2e86', fullName: 'Big Pig', email: 'BigPig@local.com', phoneNumber: '0900000000', userName: 'pig pig', }); users.push({ id: '80f78f75-37b5-4977-bffc-5afc5db99123', fullName: 'Pink Chicken', email: 'PinkChicken@local.com', phoneNumber: '0900000011', userName: 'Hi Chicken', }); return users; } /** 使用 user id 查詢使用者 * * @param id user id * @returns user */ async getUserById(id: string): Promise&lt;UserDto&gt; { let user: UserDto = { id: '80f78f75-37b5-4977-bffc-5afc5db99123', fullName: 'Pink Chicken', email: 'PinkChicken@local.com', phoneNumber: '0900000011', userName: 'Hi Chicken', }; return user; } /** 新增使用者 * * @param newUser new user * @returns new user list */ async createUser(newUser: CreateUserDto): Promise&lt;Array&lt;UserDto&gt;&gt; { let users = new Array&lt;UserDto&gt;(); users.push({ id: '591afd77-32d0-44c2-a487-b6bd8850a0fe', fullName: newUser.fullName, email: newUser.email, phoneNumber: newUser.phoneNumber, userName: newUser.userName, }); users.push({ id: 'f7541155-a4ff-4ca2-bfc5-a82ad98e2e86', fullName: 'Big Pig', email: 'BigPig@local.com', phoneNumber: '0900000000', userName: 'pig pig', }); users.push({ id: '80f78f75-37b5-4977-bffc-5afc5db99123', fullName: 'Pink Chicken', email: 'PinkChicken@local.com', phoneNumber: '0900000011', userName: 'Hi Chicken', }); return users; } /**更新使用者 * * @param id user id * @param oldUser edit user * @returns user list */ async updaterUser( id: string, oldUser: UpdateUserDto, ): Promise&lt;Array&lt;UserDto&gt;&gt; { let users = new Array&lt;UserDto&gt;(); users.push({ id: 'f7541155-a4ff-4ca2-bfc5-a82ad98e2e86', fullName: oldUser.fullName, email: oldUser.email, phoneNumber: oldUser.phoneNumber, userName: oldUser.fullName, }); users.push({ id: '80f78f75-37b5-4977-bffc-5afc5db99123', fullName: 'Pink Chicken', email: 'PinkChicken@local.com', phoneNumber: '0900000011', userName: 'Hi Chicken', }); return users; } /**刪除使用者 * * @param id user id * @returns user list */ async deleteUser(id: string): Promise&lt;Array&lt;UserDto&gt;&gt; { let users = new Array&lt;UserDto&gt;(); users.push({ id: '80f78f75-37b5-4977-bffc-5afc5db99123', fullName: 'Pink Chicken', email: 'PinkChicken@local.com', phoneNumber: '0900000011', userName: 'Hi Chicken', }); return users; } }  ","version":"Next","tagName":"h3"},{"title":"建立 controller​","type":1,"pageTitle":"🐔 建立一個新的模組","url":"/docs/nest/createModul#建立-controller","content":"這邊採用 RESTful API 風格 並且作了增刪查改的功能 在 user 資料夾底下建立 user.controller.ts 檔案 user └─dto │ └─create-user.dto.ts │ │ │ └─update-user.dto.ts │ │ │ └─user.dto.ts │ │ │ └─index.ts │ └─user.controller.ts │ └─user.service.ts  服務注入  constructor(private readonly userService: UserService) {}  整體程式碼 import { Controller, Get, Post, Body, Put, Param, Delete, } from '@nestjs/common'; import { UpdateUserDto, CreateUserDto, UserDto } from './dto'; import { UserService } from './user.service'; @Controller('user') export class UserController { constructor(private readonly userService: UserService) {} @Get(':storeId') async findAll(@Param('id') storeId: string): Promise&lt;Array&lt;UserDto&gt;&gt; { return await this.userService.getUserByStoreId(storeId); } @Get(':id') async findOne(@Param('id') id: string): Promise&lt;UserDto&gt; { return await this.userService.getUserById(id); } @Post() async create(@Body() createCatDto: CreateUserDto) { return await this.userService.createUser(createCatDto); } @Put(':id') async update(@Param('id') id: string, @Body() updateCatDto: UpdateUserDto) { return await this.userService.updaterUser(id, updateCatDto); } @Delete(':id') async remove(@Param('id') id: string) { return await this.userService.deleteUser(id); } }  ","version":"Next","tagName":"h3"},{"title":"建置 module​","type":1,"pageTitle":"🐔 建立一個新的模組","url":"/docs/nest/createModul#建置-module","content":"主要來管理 controller, service 的生週期 建立 user.module.ts user └─dto │ └─create-user.dto.ts │ │ │ └─update-user.dto.ts │ │ │ └─user.dto.ts │ │ │ └─index.ts │ └─user.controller.ts │ └─user.service.ts │ └─user.module.ts  import { Module } from '@nestjs/common'; import { UserController } from './user.controller'; import { UserService } from './user.service'; @Module({ controllers: [UserController], providers: [UserService], }) export class UserModule {}  ","version":"Next","tagName":"h3"},{"title":"將 Module 註冊於 app​","type":1,"pageTitle":"🐔 建立一個新的模組","url":"/docs/nest/createModul#將-module-註冊於-app","content":"到 app.module.ts 加入 user.module.ts import { Module } from '@nestjs/common'; import { AppController } from './app.controller'; import { AppService } from './app.service'; import { UserModule } from './user/user.module'; @Module({ imports: [UserModule], controllers: [AppController], providers: [AppService], }) export class AppModule {}  ","version":"Next","tagName":"h3"},{"title":"🐔 全域工具包 UUID","type":0,"sectionRef":"#","url":"/docs/nest/createUtail","content":"","keywords":"","version":"Next"},{"title":"關於全域工具包 UUID​","type":1,"pageTitle":"🐔 全域工具包 UUID","url":"/docs/nest/createUtail#關於全域工具包-uuid","content":"為甚麼要特地提供一個 UUID 服務呢? 為了做測試隔離會有好幾個模組需要使用到這個功能 ","version":"Next","tagName":"h2"},{"title":"製作全域工具包 UUID​","type":1,"pageTitle":"🐔 全域工具包 UUID","url":"/docs/nest/createUtail#製作全域工具包-uuid","content":"先建立一個 uuid 的資料夾 src └─user │ └─uuid │ └─app.controller.spec.ts │ └─app.controller.ts │ └─app.module.ts │ └─app.service.ts │ └─main.ts  ","version":"Next","tagName":"h2"},{"title":"建立 interface​","type":1,"pageTitle":"🐔 全域工具包 UUID","url":"/docs/nest/createUtail#建立-interface","content":"在 uuid 資料夾底下，建立一個 uuid.service.interface.ts uuid └─uuid.service.interface.ts  export interface UUIDServiceInterface { /** * 回傳 uuid */ getUUID(): string; }  ","version":"Next","tagName":"h3"},{"title":"建立 service​","type":1,"pageTitle":"🐔 全域工具包 UUID","url":"/docs/nest/createUtail#建立-service","content":"此處可以使用 nest cli 來建立一個 service nest generate service uuid  uuid └─uuid.service.interface.ts | └─uuid.service.ts | └─uuid.service.spec.ts  uuid.service.spec.ts 是在進行測試使用的 import { Injectable } from '@nestjs/common'; import { UUIDServiceInterface } from './uuid.service.interface'; import { v4 as uuidv4 } from 'uuid'; @Injectable() export class UUIDService implements UUIDServiceInterface { /** * 取得 uuid */ async getUUID(): Promise&lt;string&gt; { const uuid = uuidv4(); return uuid; } }  ","version":"Next","tagName":"h3"},{"title":"註冊模組​","type":1,"pageTitle":"🐔 全域工具包 UUID","url":"/docs/nest/createUtail#註冊模組","content":"先使用 nest cli 建立一個 uuid.module.ts nest generate module uuid  uuid └─uuid.service.interface.ts | └─uuid.service.ts | └─uuid.module.ts | └─uuid.service.spec.ts  註冊 uuid 服務並且需要做 exports 來上匯出模組使用 @Global() 來表示他是全域的模組 import { Module ,Global } from '@nestjs/common'; import { UUIDService } from './uuid.service'; @Global() @Module({ providers: [ { provide: 'UUIDServiceInterface', useClass: UUIDService, }, ], exports: [ { provide: 'UUIDServiceInterface', useClass: UUIDService, }, ], }) export class UuidModule {}  到 app.module.ts 底下註冊 UuidModule import { Module } from '@nestjs/common'; import { AppController } from './app.controller'; import { AppService } from './app.service'; import { UserModule } from './user/user.module'; import { UuidModule } from './uuid/uuid.module'; @Module({ imports: [UserModule, UuidModule], controllers: [AppController], providers: [AppService], }) export class AppModule {}   ref 梁大哥 github ","version":"Next","tagName":"h3"},{"title":"🐔 全域工具包 TimeZone","type":0,"sectionRef":"#","url":"/docs/nest/dateTimeUtail","content":"","keywords":"","version":"Next"},{"title":"關於全域工具包 TimeZone​","type":1,"pageTitle":"🐔 全域工具包 TimeZone","url":"/docs/nest/dateTimeUtail#關於全域工具包-timezone","content":"為甚麼要特地提供一個 UUID 服務呢? 為了做測試隔離會有好幾個模組需要使用到這個功能在雲端服務中，直接取 local time 會取到伺服器當地的時間，造成時間不準確的問題 ","version":"Next","tagName":"h2"},{"title":"製作全域工具包 TimeZone​","type":1,"pageTitle":"🐔 全域工具包 TimeZone","url":"/docs/nest/dateTimeUtail#製作全域工具包-timezone","content":"先建立一個 clock 的資料夾 src └─user │ └─uuid │ └─clock │ └─app.controller.spec.ts │ └─app.controller.ts │ └─app.module.ts │ └─app.service.ts │ └─main.ts  ","version":"Next","tagName":"h2"},{"title":"建立 interface​","type":1,"pageTitle":"🐔 全域工具包 TimeZone","url":"/docs/nest/dateTimeUtail#建立-interface","content":"在 uuid 資料夾底下，建立一個 clock.service.interface.ts clock └─clock.service.interface.ts  export interface ClockServiceInterface{ /** * 取得 +8 時間 */ getTime():string; }  ","version":"Next","tagName":"h3"},{"title":"建立 service​","type":1,"pageTitle":"🐔 全域工具包 TimeZone","url":"/docs/nest/dateTimeUtail#建立-service","content":"此處可以使用 nest cli 來建立一個 service nest generate service clock  clock └─clock.service.interface.ts | └─clock.service.ts | └─clock.service.spec.ts  clock.service.spec.ts 是在進行測試使用的 import { Injectable } from '@nestjs/common'; import { ClockServiceInterface } from './clock.service.interface'; @Injectable() export class ClockService implements ClockServiceInterface { /** * 取得標準時間 * @returns */ private getTimeZone(): Date { const utcTime = new Date().getTime() + new Date().getTimezoneOffset() * 60 * 1000; return new Date(utcTime); } /** * 取得 +8 時間 */ getTime(): string { const offset = 8 * 60; // 8小時的分鐘數 const utcTime = this.getTimeZone().getTime(); // 使用 getTimeZone() 取得標準時間 const localTime = new Date(utcTime + offset * 60 * 1000); return localTime.toISOString(); } }  ","version":"Next","tagName":"h3"},{"title":"註冊模組​","type":1,"pageTitle":"🐔 全域工具包 TimeZone","url":"/docs/nest/dateTimeUtail#註冊模組","content":"先使用 nest cli 建立一個 clock.module.ts nest generate module clock  clock └─clock.service.interface.ts | └─clock.service.ts | └─clock.module.ts | └─clock.service.spec.ts  註冊 clock 服務並且需要做 exports 來上匯出模組使用 @Global() 來表示他是全域的模組 import { Global, Module } from '@nestjs/common'; import { ClockService } from './clock.service'; @Global() @Module({ providers: [ { provide: 'ClockServiceInterface', useClass: ClockService, }, ], exports: [ { provide: 'ClockServiceInterface', useClass: ClockService, }, ], }) export class ClockModule {}  到 app.module.ts 底下註冊 UuidModule import { Module } from '@nestjs/common'; import { AppController } from './app.controller'; import { AppService } from './app.service'; import { UserModule } from './user/user.module'; import { UuidModule } from './uuid/uuid.module'; import { ClockModule } from './clock/clock.module'; @Module({ imports: [UserModule, UuidModule, ClockModule], controllers: [AppController], providers: [AppService], }) export class AppModule {}  ","version":"Next","tagName":"h3"},{"title":"注意事項​","type":1,"pageTitle":"🐔 全域工具包 TimeZone","url":"/docs/nest/dateTimeUtail#注意事項","content":"警告 如果直接將 Date 物件，透過 controller 帶給客戶端，那麼客戶端拿到的會是格林威治時間， 所以必須將時間轉換成ISO string或是time stamp ","version":"Next","tagName":"h3"},{"title":"🐔 Exception filter","type":0,"sectionRef":"#","url":"/docs/nest/exceptionFilter","content":"","keywords":"","version":"Next"},{"title":"定義​","type":1,"pageTitle":"🐔 Exception filter","url":"/docs/nest/exceptionFilter#定義","content":"","version":"Next","tagName":"h2"},{"title":"關於 Exception​","type":1,"pageTitle":"🐔 Exception filter","url":"/docs/nest/exceptionFilter#關於-exception","content":"exception 指的是程式執行過程中，發生的例外狀況 導致程式沒辦法正確的執行 ","version":"Next","tagName":"h3"},{"title":"關於 filter​","type":1,"pageTitle":"🐔 Exception filter","url":"/docs/nest/exceptionFilter#關於-filter","content":"filter 的生命週期會是，在客戶端 API 發送後，先抵達 controller，接下來才會回到 filter ","version":"Next","tagName":"h3"},{"title":"關於 Exception filter​","type":1,"pageTitle":"🐔 Exception filter","url":"/docs/nest/exceptionFilter#關於-exception-filter","content":"將前面的名詞合併 Exception + filter 這邊的用途是全域例外攔截器，整個系統的例外都會被這邊攔截，並且進行處理 ","version":"Next","tagName":"h3"},{"title":"實作 Exception filter​","type":1,"pageTitle":"🐔 Exception filter","url":"/docs/nest/exceptionFilter#實作-exception-filter","content":"","version":"Next","tagName":"h2"},{"title":"建立目檔案​","type":1,"pageTitle":"🐔 Exception filter","url":"/docs/nest/exceptionFilter#建立目檔案","content":"建立 all-exceptions.filter.ts src └─user │ └─app.controller.spec.ts │ └─app.controller.ts │ └─app.module.ts │ └─all-exceptions.filter.ts │ └─app.service.ts │ └─main.ts  ","version":"Next","tagName":"h3"},{"title":"建立全域過濾器​","type":1,"pageTitle":"🐔 Exception filter","url":"/docs/nest/exceptionFilter#建立全域過濾器","content":"在全域過濾器中，也自定義了例外拾回傳的格式 import { ExceptionFilter, Catch, ArgumentsHost, HttpException, HttpStatus, } from '@nestjs/common'; import { HttpAdapterHost } from '@nestjs/core'; @Catch() export class AllExceptionsFilter implements ExceptionFilter { constructor(private readonly httpAdapterHost: HttpAdapterHost) { } catch(exception: unknown, host: ArgumentsHost): void { // In certain situations `httpAdapter` might not be available in the // constructor method, thus we should resolve it here. const { httpAdapter } = this.httpAdapterHost; const ctx = host.switchToHttp(); const msg = exception instanceof Error ? exception.message : 'unknown message'; const httpStatus = exception instanceof HttpException ? exception.getStatus() : HttpStatus.INTERNAL_SERVER_ERROR; const responseBody = { statusCode: httpStatus, msg: msg, timestamp: new Date().toISOString(), path: httpAdapter.getRequestUrl(ctx.getRequest()), }; httpAdapter.reply(ctx.getResponse(), responseBody, httpStatus); } }  ","version":"Next","tagName":"h3"},{"title":"註冊全域的過濾器​","type":1,"pageTitle":"🐔 Exception filter","url":"/docs/nest/exceptionFilter#註冊全域的過濾器","content":"於 app.module.ts 註冊 @Module({ imports: [ InhabitantModule, ], controllers: [AppController], providers: [AppService, { provide: APP_FILTER, useClass: AllExceptionsFilter, } ], }) export class AppModule { }  ","version":"Next","tagName":"h3"},{"title":"🐔 Multi-stage Build","type":0,"sectionRef":"#","url":"/docs/nest/multiStageBuild","content":"","keywords":"","version":"Next"},{"title":"為何要使用 Multi-stage Build​","type":1,"pageTitle":"🐔 Multi-stage Build","url":"/docs/nest/multiStageBuild#為何要使用-multi-stage-build","content":"在直接建立 nest 的 docker image 時， image 至少會 400 多 mb，如果要進行瘦身打包那勢必需要執行此動作 ","version":"Next","tagName":"h2"},{"title":"試做 nest Multi-stage Build​","type":1,"pageTitle":"🐔 Multi-stage Build","url":"/docs/nest/multiStageBuild#試做-nest-multi-stage-build","content":"","version":"Next","tagName":"h2"},{"title":"dockerfile​","type":1,"pageTitle":"🐔 Multi-stage Build","url":"/docs/nest/multiStageBuild#dockerfile","content":"此步驟是先使用開發環境進行打包，接下來依靠 pnpm 來安裝生產環境所需要用到的依賴 # development image FROM node:alpine AS development # 建立app目錄 WORKDIR /usr/src/app # 複製依賴檔 COPY package*.json ./ COPY tsconfig*.json ./ # 下載 pnpm RUN npm i -g pnpm # 複製程式碼 COPY . . /usr/src/app/ # 下載依賴 RUN pnpm install -r # 部屬專案 RUN pnpm run build # production image FROM node:alpine AS production # 建立app目錄 WORKDIR /usr/src/app # 複製依賴檔 COPY package.json ./ COPY pnpm-lock.yaml ./ # 下載 pnpm RUN npm i -g pnpm # 下載依賴(只下載需使用的依賴) RUN pnpm install --prod # 複製剛剛打包的檔案 COPY --from=development /usr/src/app/dist ./dist # 啟動服務 CMD [ &quot;node&quot;, &quot;dist/main.js&quot; ]   ref: Multi-stage Build, Miles 梁大哥 github ","version":"Next","tagName":"h3"},{"title":"🐔 Nest CLI 常用指令","type":0,"sectionRef":"#","url":"/docs/nest/nestCliCmd","content":"","keywords":"","version":"Next"},{"title":"建立 project​","type":1,"pageTitle":"🐔 Nest CLI 常用指令","url":"/docs/nest/nestCliCmd#建立-project","content":"nest new [project-name]  ","version":"Next","tagName":"h2"},{"title":"建立 controller​","type":1,"pageTitle":"🐔 Nest CLI 常用指令","url":"/docs/nest/nestCliCmd#建立-controller","content":"nest generate controller [module name]  ","version":"Next","tagName":"h2"},{"title":"建立 service​","type":1,"pageTitle":"🐔 Nest CLI 常用指令","url":"/docs/nest/nestCliCmd#建立-service","content":"nest generate service [module name]  ","version":"Next","tagName":"h2"},{"title":"建立 module​","type":1,"pageTitle":"🐔 Nest CLI 常用指令","url":"/docs/nest/nestCliCmd#建立-module","content":"nest generate module [module name]  ","version":"Next","tagName":"h2"},{"title":"縮寫​","type":1,"pageTitle":"🐔 Nest CLI 常用指令","url":"/docs/nest/nestCliCmd#縮寫","content":"nest generate 縮寫 nest g  ","version":"Next","tagName":"h3"},{"title":"🐔 NestJS 設定啟動 Port","type":0,"sectionRef":"#","url":"/docs/nest/nestStartPort","content":"🐔 NestJS 設定啟動 Port 於檔案 src/main.ts import { NestFactory } from '@nestjs/core'; import { AppModule } from './app.module'; async function bootstrap() { const app = await NestFactory.create(AppModule); await app.listen(3050); } bootstrap(); ","keywords":"","version":"Next"},{"title":"🐔 NestJS 的 Docker Compose","type":0,"sectionRef":"#","url":"/docs/nest/useDockerCompose","content":"","keywords":"","version":"Next"},{"title":"環境​","type":1,"pageTitle":"🐔 NestJS 的 Docker Compose","url":"/docs/nest/useDockerCompose#環境","content":"NestJsPostgresql ","version":"Next","tagName":"h2"},{"title":"Docker Compose 準備​","type":1,"pageTitle":"🐔 NestJS 的 Docker Compose","url":"/docs/nest/useDockerCompose#docker-compose-準備","content":"","version":"Next","tagName":"h2"},{"title":"撰寫 dockerfile​","type":1,"pageTitle":"🐔 NestJS 的 Docker Compose","url":"/docs/nest/useDockerCompose#撰寫-dockerfile","content":"參考 🐔 NestJS 的 dockerfile 撰寫 dockerfile ","version":"Next","tagName":"h3"},{"title":"撰寫 docker-compose.yml​","type":1,"pageTitle":"🐔 NestJS 的 Docker Compose","url":"/docs/nest/useDockerCompose#撰寫-docker-composeyml","content":"在專案底下建立 docker-compose.yml version: '3.8' services: nest-app: container_name: nest-app build: context: . dockerfile: Dockerfile ports: - &quot;80:3050&quot; depends_on: - postgres environment: POSTGRES_HOST: postgres POSTGRES_PORT: 5432 POSTGRES_USER: postgres POSTGRES_PASSWORD: test123 POSTGRES_DB: [your_database_name] postgres: container_name: postgres12 image: postgres:12.3 environment: POSTGRES_PASSWORD: test123 ports: - &quot;5432:5432&quot;  ","version":"Next","tagName":"h3"},{"title":"啟動​","type":1,"pageTitle":"🐔 NestJS 的 Docker Compose","url":"/docs/nest/useDockerCompose#啟動","content":"docker-compose up  ","version":"Next","tagName":"h3"},{"title":"🐔 NestJS 的 dockerfile","type":0,"sectionRef":"#","url":"/docs/nest/writeDockerfile","content":"","keywords":"","version":"Next"},{"title":"建立檔案​","type":1,"pageTitle":"🐔 NestJS 的 dockerfile","url":"/docs/nest/writeDockerfile#建立檔案","content":"在專案底下建立一個檔案 dockerfile # node image FROM node:18-alpine # 建立app目錄 WORKDIR /usr/src/app # 複製依賴檔 COPY package*.json ./ COPY tsconfig*.json ./ # 複製程式碼 COPY . . # 下載依賴 RUN npm install # 部屬專案 RUN npm run build # 啟動服務 CMD [ &quot;node&quot;, &quot;dist/main.js&quot; ]  在專案底下建立一個檔案 .dockerignore，來過濾用不到的檔案 dockerfile .dockerignore node_modules npm-debug.log dist  ","version":"Next","tagName":"h2"},{"title":"建立 image​","type":1,"pageTitle":"🐔 NestJS 的 dockerfile","url":"/docs/nest/writeDockerfile#建立-image","content":"docker build -t nest-app .  ","version":"Next","tagName":"h2"},{"title":"啟動 nest 容器​","type":1,"pageTitle":"🐔 NestJS 的 dockerfile","url":"/docs/nest/writeDockerfile#啟動-nest-容器","content":"docker run -p 80:3050 nest-app  ","version":"Next","tagName":"h2"},{"title":"🐔 理解 Nest 的單元測試","type":0,"sectionRef":"#","url":"/docs/test/unitTest","content":"","keywords":"","version":"Next"},{"title":"關於單元測試​","type":1,"pageTitle":"🐔 理解 Nest 的單元測試","url":"/docs/test/unitTest#關於單元測試","content":"在 Nest js 中，預設的測試框架為 Jest 其中提供了 斷言、mock 等等測試功能 ","version":"Next","tagName":"h2"},{"title":"從官網範例理解測試生命週期​","type":1,"pageTitle":"🐔 理解 Nest 的單元測試","url":"/docs/test/unitTest#從官網範例理解測試生命週期","content":"","version":"Next","tagName":"h2"},{"title":"範例程式​","type":1,"pageTitle":"🐔 理解 Nest 的單元測試","url":"/docs/test/unitTest#範例程式","content":"import { CatsController } from './cats.controller'; import { CatsService } from './cats.service'; describe('CatsController', () =&gt; { let catsController: CatsController; let catsService: CatsService; beforeEach(() =&gt; { catsService = new CatsService(); catsController = new CatsController(catsService); }); describe('findAll', () =&gt; { it('should return an array of cats', async () =&gt; { const result = ['test']; jest.spyOn(catsService, 'findAll').mockImplementation(() =&gt; result); expect(await catsController.findAll()).toBe(result); }); }); });  ","version":"Next","tagName":"h3"},{"title":"生命週期-import​","type":1,"pageTitle":"🐔 理解 Nest 的單元測試","url":"/docs/test/unitTest#生命週期-import","content":"CatsController 和 CatsService 的匯入：程式碼開頭匯入是被測試的控制器和服務 import { CatsController } from './cats.controller'; import { CatsService } from './cats.service';  ","version":"Next","tagName":"h3"},{"title":"生命週期-describe for class​","type":1,"pageTitle":"🐔 理解 Nest 的單元測試","url":"/docs/test/unitTest#生命週期-describe-for-class","content":"describe：這是 Jest 測試框架中的函式，用來定義一個測試套件，這個套件專門用來測試 CatsController 類別 describe('CatsController', () =&gt; { });  ","version":"Next","tagName":"h3"},{"title":"生命週期-beforeEach​","type":1,"pageTitle":"🐔 理解 Nest 的單元測試","url":"/docs/test/unitTest#生命週期-beforeeach","content":"beforeEach：在每個測試案例執行之前，beforeEach 函式會被執行 在這個區塊中，我們建立了一個新的 CatsService 實例，並注入到一個新的 CatsController 實例中  let catsController: CatsController; let catsService: CatsService; beforeEach(() =&gt; { catsService = new CatsService(); catsController = new CatsController(catsService); });  ","version":"Next","tagName":"h3"},{"title":"生命週期-describe for function​","type":1,"pageTitle":"🐔 理解 Nest 的單元測試","url":"/docs/test/unitTest#生命週期-describe-for-function","content":"describe('findAll', ...)：用它來定義我要測試的函式  describe('findAll', () =&gt; { });  ","version":"Next","tagName":"h3"},{"title":"生命週期-it​","type":1,"pageTitle":"🐔 理解 Nest 的單元測試","url":"/docs/test/unitTest#生命週期-it","content":"it：他的單位為一個測試案例(test case) it('should return an array of cats', async () =&gt; { });  ","version":"Next","tagName":"h3"},{"title":"生命週期-jest.spyOn​","type":1,"pageTitle":"🐔 理解 Nest 的單元測試","url":"/docs/test/unitTest#生命週期-jestspyon","content":"jest.spyOn：這是一個 mock，用來做假物件，離掉真實物件的相依性(只專注在該內部邏輯，外部都做隔離) 在這邊預設，catsService 的 findAll 會回傳 ['test'] const result = ['test']; jest.spyOn(catsService, 'findAll').mockImplementation(() =&gt; result);  ","version":"Next","tagName":"h3"},{"title":"生命週期-expect​","type":1,"pageTitle":"🐔 理解 Nest 的單元測試","url":"/docs/test/unitTest#生命週期-expect","content":"expect：這是斷言語句，它驗證呼叫 catsController.findAll() 方法的結果是否等於我們預期的 result const result = ['test']; jest.spyOn(catsService, 'findAll').mockImplementation(() =&gt; result); expect(await catsController.findAll()).toBe(result);  經過以上步驟就完成一個單元測試的程式 ","version":"Next","tagName":"h3"},{"title":"名詞回顧​","type":1,"pageTitle":"🐔 理解 Nest 的單元測試","url":"/docs/test/unitTest#名詞回顧","content":"名詞\tNUnit 名詞對照\t說明describe (for class)\tTestFixture\t標示為測試類別 beforeEach\tSetUp\t標示為初始化 describe (for function)\tTest or TestCase\t標示測試的函式 it\tTest or TestCase\t測試案例 jest.spyOn\tNSubstitute.Substitute\tmock，用來做假物件，離掉真實物件的相依性 expect\tAssert\t斷言  ref 梁大哥解說 ","version":"Next","tagName":"h2"},{"title":"🐔 單元測試實作","type":0,"sectionRef":"#","url":"/docs/test/createUnitTest","content":"","keywords":"","version":"Next"},{"title":"需求​","type":1,"pageTitle":"🐔 單元測試實作","url":"/docs/test/createUnitTest#需求","content":"我需要一個檢查物件的服務如果物件是字串，就需要檢查它是否為空字串如果物件是數字，就要檢查它是不是 NaN如果有錯誤的話都要上拋例外 ","version":"Next","tagName":"h2"},{"title":"實作單元測試​","type":1,"pageTitle":"🐔 單元測試實作","url":"/docs/test/createUnitTest#實作單元測試","content":"src └─user │ └─uuid │ └─error-check │ └─clock │ └─app.controller.spec.ts │ └─app.controller.ts │ └─app.module.ts │ └─app.service.ts │ └─main.ts  ","version":"Next","tagName":"h2"},{"title":"定義服務會提供的介面​","type":1,"pageTitle":"🐔 單元測試實作","url":"/docs/test/createUnitTest#定義服務會提供的介面","content":"建立一個 error-check.service.interface.ts先想好要提供什麼要的 input 與 output error-check └─error-check.service.interface.ts  export interface ErrorCheckServiceInterface { /** * 檢查字串是否為空 * @param str */ isNullOrEmpty(str: string): boolean; /** * 檢查資料是否為空 * @param dataName 資料名稱 * @param data 需要被檢查的資料 */ checkOneValue&lt;T&gt;(dataName: string, data: T): void; }  ","version":"Next","tagName":"h3"},{"title":"建立服務檔案​","type":1,"pageTitle":"🐔 單元測試實作","url":"/docs/test/createUnitTest#建立服務檔案","content":"建立服務與測試 nest generate service error-check  error-check └─error-check.service.interface.ts | └─error-check.service.ts | └─error-check.service.spec.ts  ","version":"Next","tagName":"h3"},{"title":"先寫測試​","type":1,"pageTitle":"🐔 單元測試實作","url":"/docs/test/createUnitTest#先寫測試","content":"測試的檔案為 error-check.service.spec.ts先做好測試的前置準備 import { Test, TestingModule } from '@nestjs/testing'; import { ErrorCheckService } from './error-check.service'; describe('ErrorCheckService', () =&gt; { let errorCheckService: ErrorCheckService; beforeEach(async () =&gt; { // 在容器中註冊我要做測試的服務 const module: TestingModule = await Test.createTestingModule({ providers: [ErrorCheckService], }).compile(); // 從容器中取出我要測試的服務 errorCheckService = module.get&lt;ErrorCheckService&gt;(ErrorCheckService); }); });  ","version":"Next","tagName":"h2"},{"title":"需求1: 如果物件是字串，就需要檢查它是否為空字串​","type":1,"pageTitle":"🐔 單元測試實作","url":"/docs/test/createUnitTest#需求1-如果物件是字串就需要檢查它是否為空字串","content":"這邊測試兩個劇情 劇情1: 資料為空的話，我應該會收到一個例外 劇情2: 資料是正常的字串，應該要正常運作  it('should throw an error when given an empty string', () =&gt; { expect(() =&gt; errorCheckService.checkOneValue('data', '')).toThrowError('data,資料不能為空或未定義'); }); it('should not throw an error when given a valid string', () =&gt; { // 應該不會拋出錯誤 expect(() =&gt; errorCheckService.checkOneValue('data', 'valid')).not.toThrow(); });  ","version":"Next","tagName":"h3"},{"title":"需求2: 如果物件是數字，就要檢查它是不是 NaN​","type":1,"pageTitle":"🐔 單元測試實作","url":"/docs/test/createUnitTest#需求2-如果物件是數字就要檢查它是不是-nan","content":"這邊測試兩個劇情 劇情1: 資料為 NaN 的話，我應該會收到一個例外 劇情2: 資料是正常的數字，應該要正常運作  it('should throw an error when given NaN', () =&gt; { expect(() =&gt; errorCheckService.checkOneValue('data', NaN)).toThrowError('data,資料不能為 NaN'); }); it('should not throw an error when given a valid number', () =&gt; { // 應該不會拋出錯誤 expect(() =&gt; errorCheckService.checkOneValue('data', 42)).not.toThrow(); });  ","version":"Next","tagName":"h3"},{"title":"需求3: 如果有錯誤的話都要上拋例外​","type":1,"pageTitle":"🐔 單元測試實作","url":"/docs/test/createUnitTest#需求3-如果有錯誤的話都要上拋例外","content":"這邊測試兩個劇情 劇情1: 如果資料是 undefined，就要跳出 data,資料未定義 的例外 劇情2: 如果資料是沒有要檢查的型別，就要跳出 不支援的資料型別 的例外  it('should throw an error when given undefined data', () =&gt; { expect(() =&gt; errorCheckService.checkOneValue('data', undefined)).toThrowError('data,資料未定義'); }); it('should throw an error for unsupported data type', () =&gt; { expect(() =&gt; errorCheckService.checkOneValue('data', {})).toThrowError('不支援的資料型別'); });  ","version":"Next","tagName":"h3"},{"title":"完整的測試程式碼​","type":1,"pageTitle":"🐔 單元測試實作","url":"/docs/test/createUnitTest#完整的測試程式碼","content":"import { Test, TestingModule } from '@nestjs/testing'; import { ErrorCheckService } from './error-check.service'; describe('ErrorCheckService', () =&gt; { let errorCheckService: ErrorCheckService; beforeEach(async () =&gt; { const module: TestingModule = await Test.createTestingModule({ providers: [ErrorCheckService], }).compile(); errorCheckService = module.get&lt;ErrorCheckService&gt;(ErrorCheckService); }); it('should throw an error when given an empty string', () =&gt; { expect(() =&gt; errorCheckService.checkOneValue('data', '')).toThrowError('data,資料不能為空或未定義'); }); it('should throw an error when given undefined data', () =&gt; { expect(() =&gt; errorCheckService.checkOneValue('data', undefined)).toThrowError('data,資料未定義'); }); it('should throw an error when given NaN', () =&gt; { expect(() =&gt; errorCheckService.checkOneValue('data', NaN)).toThrowError('data,資料不能為 NaN'); }); it('should throw an error for unsupported data type', () =&gt; { expect(() =&gt; errorCheckService.checkOneValue('data', {})).toThrowError('不支援的資料型別'); }); it('should not throw an error when given a valid string', () =&gt; { // 應該不會拋出錯誤 expect(() =&gt; errorCheckService.checkOneValue('data', 'valid')).not.toThrow(); }); it('should not throw an error when given a valid number', () =&gt; { // 應該不會拋出錯誤 expect(() =&gt; errorCheckService.checkOneValue('data', 42)).not.toThrow(); }); });  ","version":"Next","tagName":"h3"},{"title":"開始寫服務​","type":1,"pageTitle":"🐔 單元測試實作","url":"/docs/test/createUnitTest#開始寫服務","content":"","version":"Next","tagName":"h2"},{"title":"error-check.service.ts​","type":1,"pageTitle":"🐔 單元測試實作","url":"/docs/test/createUnitTest#error-checkservicets","content":"import { Injectable } from '@nestjs/common'; import { ErrorCheckServiceInterface } from './error-check.service.interface'; @Injectable() export class ErrorCheckService implements ErrorCheckServiceInterface { /** * 檢查字串是否為空 * @param str */ isNullOrEmpty(str: string): boolean { return !str || str == undefined || str == '' || str.length == 0; } /** * 檢查資料是否為空 * @param dataName 資料名稱 * @param data 需要被檢查的資料 */ checkOneValue&lt;T&gt;(dataName: string, data: T): void { switch (typeof data) { case 'string': if (this.isNullOrEmpty(data)) throw new Error(`${dataName},資料不能為空或未定義`); break; case 'number': if (isNaN(data)) throw new Error(`${dataName},資料不能為 NaN`); break; case 'undefined': throw new Error(`${dataName},資料未定義`); default: throw new Error('不支援的資料型別'); } } }  ","version":"Next","tagName":"h3"},{"title":"註冊服務​","type":1,"pageTitle":"🐔 單元測試實作","url":"/docs/test/createUnitTest#註冊服務","content":"先建立一個 module nest generate module error-check  import { Global, Module } from '@nestjs/common'; import { ErrorCheckService } from './error-check.service'; @Global() @Module({ providers: [ { provide: 'ErrorCheckServiceInterface', useClass: ErrorCheckService, }, ], exports: [ { provide: 'ErrorCheckServiceInterface', useClass: ErrorCheckService, }, ], }) export class ErrorCheckModule {}  app.module.ts import { Module } from '@nestjs/common'; import { AppController } from './app.controller'; import { AppService } from './app.service'; import { UserModule } from './user/user.module'; import { UuidModule } from './uuid/uuid.module'; import { ClockModule } from './clock/clock.module'; import { ErrorCheckModule } from './error-check/error-check.module'; @Module({ imports: [UserModule, UuidModule, ClockModule, ErrorCheckModule], controllers: [AppController], providers: [AppService], }) export class AppModule {}  ","version":"Next","tagName":"h3"},{"title":"進行測試​","type":1,"pageTitle":"🐔 單元測試實作","url":"/docs/test/createUnitTest#進行測試","content":"","version":"Next","tagName":"h2"},{"title":"測試指令​","type":1,"pageTitle":"🐔 單元測試實作","url":"/docs/test/createUnitTest#測試指令","content":"進行所有測試 pnpm test  針對某個測試執行 pnpm test:watch src/error-check/error-check.service.spec.ts  測試過程中可以下中斷點 debug pnpm test:debug  ","version":"Next","tagName":"h3"},{"title":"執行​","type":1,"pageTitle":"🐔 單元測試實作","url":"/docs/test/createUnitTest#執行","content":"這邊執行 pnpm test:watch src/error-check/error-check.service.spec.ts  ","version":"Next","tagName":"h3"},{"title":"測試結果​","type":1,"pageTitle":"🐔 單元測試實作","url":"/docs/test/createUnitTest#測試結果","content":" PASS src/error-check/error-check.service.spec.ts ErrorCheckService √ should throw an error when given an empty string (35 ms) √ should throw an error when given undefined data (5 ms) √ should throw an error when given NaN (3 ms) √ should throw an error for unsupported data type (4 ms) √ should not throw an error when given a valid string (5 ms) √ should not throw an error when given a valid number (3 ms) Waiting for the debugger to disconnect... Waiting for the debugger to disconnect... Waiting for the debugger to disconnect... Waiting for the debugger to disconnect... Test Suites: 1 passed, 1 total Tests: 6 passed, 6 total Snapshots: 0 total Time: 6.617 s  可以看到測試後的數據與結果 ","version":"Next","tagName":"h3"},{"title":"🐔 單元測試 mock","type":0,"sectionRef":"#","url":"/docs/test/unitTestMock","content":"","keywords":"","version":"Next"},{"title":"關於 mock​","type":1,"pageTitle":"🐔 單元測試 mock","url":"/docs/test/unitTestMock#關於-mock","content":"單元測試中難免需要做到資料隔離，確保我每次執行都保持一致的結果 mock 就是不屬於這個測試範圍外的服務，進行虛擬化 ","version":"Next","tagName":"h2"},{"title":"進行邏輯測試​","type":1,"pageTitle":"🐔 單元測試 mock","url":"/docs/test/unitTestMock#進行邏輯測試","content":"目前目錄結構 src └─user │ └─uuid │ └─error-check │ └─clock │ └─app.controller.spec.ts │ └─app.controller.ts │ └─app.module.ts │ └─app.service.ts │ └─main.ts  目前 user 資料夾目錄結構 user └─dto │ └─create-user.dto.ts │ │ │ └─update-user.dto.ts │ │ │ └─user.dto.ts │ │ │ └─index.ts │ └─interface │ └─user.service.interface.ts │ └─user.controller.ts │ └─user.service.ts │ └─user.module.ts  ","version":"Next","tagName":"h2"},{"title":"拆分邏輯層與資料層​","type":1,"pageTitle":"🐔 單元測試 mock","url":"/docs/test/unitTestMock#拆分邏輯層與資料層","content":"新增 user.repository.ts 與 user.repository.interface.ts user └─dto │ └─interface │ └─user.service.interface.ts │ │ │ └─user.repository.interface.ts │ └─user.controller.ts │ └─user.service.ts │ └─user.repository.ts │ └─user.module.ts  先定義 介面 import { UpdateUserDto, CreateUserDto, UserDto } from '../dto'; export interface UserRepositoryInterface { /** 使用 store id 查出底下所有的使用者 * * @param storeId store id * @returns user list */ getByStoreId(storeId: string): Promise&lt;Array&lt;UserDto&gt;&gt;; /** 使用 user id 查詢使用者 * * @param id user id * @returns user */ getById(id: string): Promise&lt;UserDto&gt;; /** 新增使用者 * * @param newUser new user * @param userId update user id * @returns new user list */ createUser(newUser: CreateUserDto, userId: string): Promise&lt;Array&lt;UserDto&gt;&gt;; /**更新使用者 * * @param id user id * @param oldUser edit user * @param userId update user id * @returns user list */ updaterUser( id: string, oldUser: UpdateUserDto, userId: string, ): Promise&lt;Array&lt;UserDto&gt;&gt;; /**刪除使用者 * * @param id user id * @returns user list */ deleteUser(id: string): Promise&lt;Array&lt;UserDto&gt;&gt;; }  ","version":"Next","tagName":"h3"},{"title":"註冊 repository​","type":1,"pageTitle":"🐔 單元測試 mock","url":"/docs/test/unitTestMock#註冊-repository","content":"user.module.ts import { Module } from '@nestjs/common'; import { UserController } from './user.controller'; import { UserService } from './user.service'; import { UserRepository } from './user.repository'; @Module({ controllers: [UserController], providers: [ { provide: 'UserServiceInterface', useClass: UserService, }, { provide: 'UserRepositoryInterface', useClass: UserRepository, }, ], }) export class UserModule {}  ","version":"Next","tagName":"h3"},{"title":"先寫測試​","type":1,"pageTitle":"🐔 單元測試 mock","url":"/docs/test/unitTestMock#先寫測試","content":"","version":"Next","tagName":"h2"},{"title":"測試前置​","type":1,"pageTitle":"🐔 單元測試 mock","url":"/docs/test/unitTestMock#測試前置","content":"宣告會用到的服務 警告 import { ErrorCheckModule } from '../error-check/error-check.module'; 由於路徑並沒有跟 user.service.spec.ts 同一層，因此需要使用 ../ 否則測試運行時會吃不到檔案 import { Test, TestingModule } from '@nestjs/testing'; import { UserService } from './user.service'; import { UserDto } from './dto'; import { ErrorCheckModule } from '../error-check/error-check.module'; describe('UserService', () =&gt; { let userService: UserService; let users: Array&lt;UserDto&gt;; });  ","version":"Next","tagName":"h3"},{"title":"進行模組註冊​","type":1,"pageTitle":"🐔 單元測試 mock","url":"/docs/test/unitTestMock#進行模組註冊","content":"將有用到的外部服務 ErrorCheckModule, UserRepository 進行註冊 警告 UserRepositoryInterface 需要使用 useValue 來為這個介面提供假物件 /** 上略 */ describe('UserService', () =&gt; { let userService: UserService; let userRepository: UserRepositoryInterface; let errorCheckService: ErrorCheckServiceInterface; beforeEach(async () =&gt; { const module: TestingModule = await Test.createTestingModule({ imports:[ErrorCheckModule], providers: [ UserService, { provide: 'UserRepositoryInterface', useValue: { // 在這裡模擬 UserRepositoryInterface 的方法 getByStoreId: jest.fn(), getById: jest.fn(), createUser: jest.fn(), updaterUser: jest.fn(), deleteUser: jest.fn(), }, } ], }).compile(); }); });  ","version":"Next","tagName":"h3"},{"title":"實例化服務​","type":1,"pageTitle":"🐔 單元測試 mock","url":"/docs/test/unitTestMock#實例化服務","content":"將服務從 IOC 中取出，並賦值給物件 /** 上略 */ describe('UserService', () =&gt; { let userService: UserService; let userRepository: UserRepositoryInterface; let errorCheckService: ErrorCheckServiceInterface; let users: Array&lt;UserDto&gt;; beforeEach(async () =&gt; { const module: TestingModule = await Test.createTestingModule({ imports:[ErrorCheckModule], providers: [ UserService, { provide: 'UserRepositoryInterface', useValue: { // 在這裡模擬 UserRepositoryInterface 的方法 getByStoreId: jest.fn(), getById: jest.fn(), createUser: jest.fn(), updaterUser: jest.fn(), deleteUser: jest.fn(), }, } ], }).compile(); userService = module.get&lt;UserService&gt;(UserService); }); });  ","version":"Next","tagName":"h3"},{"title":"傳寫測試用假物件與資料​","type":1,"pageTitle":"🐔 單元測試 mock","url":"/docs/test/unitTestMock#傳寫測試用假物件與資料","content":"將服務從 IOC 中取出，並賦值給物件 /** 上略 */ describe('UserService', () =&gt; { let userService: UserService; let users: Array&lt;UserDto&gt;; beforeEach(async () =&gt; { users = new Array&lt;UserDto&gt;(); users.push({ id: 'f7541155-a4ff-4ca2-bfc5-a82ad98e2e86', fullName: 'Big Pig', email: 'BigPig@local.com', phoneNumber: '0900000000', userName: 'pig pig', }); users.push({ id: '80f78f75-37b5-4977-bffc-5afc5db99123', fullName: 'Pink Chicken', email: 'PinkChicken@local.com', phoneNumber: '0900000011', userName: 'Hi Chicken', }); const module: TestingModule = await Test.createTestingModule({ imports:[ErrorCheckModule], providers: [ UserService, { provide: 'UserRepositoryInterface', useValue: { // 在這裡模擬 UserRepositoryInterface 的方法 getByStoreId: jest.fn((storeId) =&gt; { // 在這裡模擬 getByStoreId 方法的行為 if (storeId === 'validStoreId') { return Promise.resolve(users); } else { return Promise.resolve([]); // 返回一個空陣列作為模擬 } }), getById: jest.fn((id) =&gt; { return Promise.resolve(users.find((x) =&gt; x.id === id)); }), createUser: jest.fn((newUser, userId) =&gt; { users.push({ id: '99999999-37b5-4977-bffc-5afc5db99123', fullName: newUser.fullName, email: newUser.email, phoneNumber: newUser.phoneNumber, userName: newUser.userName, }); return Promise.resolve(users); }), updaterUser: jest.fn((id, oldUser, userId) =&gt; { let data = users.find((x) =&gt; x.id === id); data.fullName = oldUser.fullName; data.email = oldUser.email; data.phoneNumber = oldUser.phoneNumber; data.userName = oldUser.userName; return Promise.resolve(users); }), deleteUser: jest.fn((id) =&gt; { users = users.filter((x) =&gt; x, id !== id); return Promise.resolve(users); }), }, } ], }).compile(); userService = module.get&lt;UserService&gt;(UserService); }); });  ","version":"Next","tagName":"h3"},{"title":"撰寫測試劇情​","type":1,"pageTitle":"🐔 單元測試 mock","url":"/docs/test/unitTestMock#撰寫測試劇情","content":"","version":"Next","tagName":"h2"},{"title":"需求: 取得商店使用者​","type":1,"pageTitle":"🐔 單元測試 mock","url":"/docs/test/unitTestMock#需求-取得商店使用者","content":"需求: 我需要透過商店 id 來取得，屬於這家店的使用者 測試劇情1 : 傳入正確的商店 id，就可以得到屬於這家店的使用者 測試劇情2 : 傳入不存在的商店 id，會得到一個空陣列 測試劇情3 : 傳入空的字串，會跳出例外 測試劇情4 : 傳入空的字串，會跳出例外  describe('getUserByStoreId', () =&gt; { // case1 it('store id is validStoreId, return users list', async () =&gt; { const storeId = 'validStoreId'; const actual = await userService.getUserByStoreId(storeId); expect(actual).toStrictEqual(users); }); // case2 it('store id is store123, return []', async () =&gt; { const storeId = 'store123'; const actual = await userService.getUserByStoreId(storeId); expect(actual).toStrictEqual([]); }); // case3 it(&quot;store id is '', throw exception data cant not empty&quot;, async () =&gt; { const storeId = ''; const expectedError = new Error('storeId,資料不能為空或未定義'); await expect( async () =&gt; await userService.getUserByStoreId(storeId), ).rejects.toThrow(expectedError); }); // case4 it('store id is undefined, throw exception data is undefined', async () =&gt; { const storeId = undefined; const expectedError = new Error('storeId,資料未定義'); await expect( async () =&gt; await userService.getUserByStoreId(storeId), ).rejects.toThrow(expectedError); }); });  ","version":"Next","tagName":"h3"},{"title":"測試細節​","type":1,"pageTitle":"🐔 單元測試 mock","url":"/docs/test/unitTestMock#測試細節","content":"toStrictEqual : 用來比對陣列，是否符合預期測試例外 先定義例外的訊息會回傳什麼接下來執行斷言toThrow : 用來比對例外訊息是否為預期結果 警告 測試過程要注意非同步的問題，如果是非同步執行，需要進行 await  const expectedError = new Error('storeId,資料不能為空或未定義'); await expect( async () =&gt; await userService.getUserByStoreId(storeId), ).rejects.toThrow(expectedError);  警告 為什麼測試例外的 expect(async () =&gt;{...}) 需要用到箭頭函式呢? 主要的原因在於，會需要用到物件本身的 ref ，才不會導致 this 指向 caller ","version":"Next","tagName":"h3"},{"title":"執行測試​","type":1,"pageTitle":"🐔 單元測試 mock","url":"/docs/test/unitTestMock#執行測試","content":"pnpm test:watch src/user/user.service.spec.ts  ","version":"Next","tagName":"h3"},{"title":"測試結果​","type":1,"pageTitle":"🐔 單元測試 mock","url":"/docs/test/unitTestMock#測試結果","content":" PASS src/user/user.service.spec.ts UserService √ should be defined (28 ms) getUserByStoreId √ store id is validStoreId, return users list (8 ms) √ store id is store123, return [] (3 ms) √ store id is '', throw exception data cant not empty (15 ms) √ store id is undefined, throw exception data is undefined (4 ms) Waiting for the debugger to disconnect... Waiting for the debugger to disconnect... Waiting for the debugger to disconnect... Waiting for the debugger to disconnect... Test Suites: 1 passed, 1 total Tests: 5 passed, 5 total Snapshots: 0 total Time: 5.932 s, estimated 11 s   ","version":"Next","tagName":"h3"},{"title":"完整測試程式碼​","type":1,"pageTitle":"🐔 單元測試 mock","url":"/docs/test/unitTestMock#完整測試程式碼","content":"import { Test, TestingModule } from '@nestjs/testing'; import { UserService } from './user.service'; import { UserDto } from './dto'; import { ErrorCheckModule } from '../error-check/error-check.module'; describe('UserService', () =&gt; { let userService: UserService; let users: Array&lt;UserDto&gt;; beforeEach(async () =&gt; { users = new Array&lt;UserDto&gt;(); users.push({ id: 'f7541155-a4ff-4ca2-bfc5-a82ad98e2e86', fullName: 'Big Pig', email: 'BigPig@local.com', phoneNumber: '0900000000', userName: 'pig pig', }); users.push({ id: '80f78f75-37b5-4977-bffc-5afc5db99123', fullName: 'Pink Chicken', email: 'PinkChicken@local.com', phoneNumber: '0900000011', userName: 'Hi Chicken', }); const module: TestingModule = await Test.createTestingModule({ imports: [ErrorCheckModule], providers: [ UserService, { provide: 'UserRepositoryInterface', useValue: { // 在這裡模擬 UserRepositoryInterface 的方法 getByStoreId: jest.fn((storeId) =&gt; { // 在這裡模擬 getByStoreId 方法的行為 if (storeId === 'validStoreId') { return Promise.resolve(users); } else { return Promise.resolve([]); // 返回一個空陣列作為模擬 } }), getById: jest.fn((id) =&gt; { return Promise.resolve(users.find((x) =&gt; x.id === id)); }), createUser: jest.fn((newUser, userId) =&gt; { users.push({ id: '99999999-37b5-4977-bffc-5afc5db99123', fullName: newUser.fullName, email: newUser.email, phoneNumber: newUser.phoneNumber, userName: newUser.userName, }); return Promise.resolve(users); }), updaterUser: jest.fn((id, oldUser, userId) =&gt; { const data = users.find((x) =&gt; x.id === id); data.fullName = oldUser.fullName; data.email = oldUser.email; data.phoneNumber = oldUser.phoneNumber; data.userName = oldUser.userName; return Promise.resolve(users); }), deleteUser: jest.fn((id) =&gt; { users = users.filter((x) =&gt; x, id !== id); return Promise.resolve(users); }), }, }, ], }).compile(); userService = module.get&lt;UserService&gt;(UserService); }); it('should be defined', () =&gt; { expect(userService).toBeDefined(); }); describe('getUserByStoreId', () =&gt; { // case1 it('store id is validStoreId, return users list', async () =&gt; { const storeId = 'validStoreId'; const actual = await userService.getUserByStoreId(storeId); expect(actual).toStrictEqual(users); }); // case2 it('store id is store123, return []', async () =&gt; { const storeId = 'store123'; const actual = await userService.getUserByStoreId(storeId); expect(actual).toStrictEqual([]); }); // case3 it(&quot;store id is '', throw exception data cant not empty&quot;, async () =&gt; { const storeId = ''; const expectedError = new Error('storeId,資料不能為空或未定義'); await expect( async () =&gt; await userService.getUserByStoreId(storeId), ).rejects.toThrow(expectedError); }); // case4 it('store id is undefined, throw exception data is undefined', async () =&gt; { const storeId = undefined; const expectedError = new Error('storeId,資料未定義'); await expect( async () =&gt; await userService.getUserByStoreId(storeId), ).rejects.toThrow(expectedError); }); }); });   ","version":"Next","tagName":"h2"},{"title":"REF​","type":1,"pageTitle":"🐔 單元測試 mock","url":"/docs/test/unitTestMock#ref","content":"梁大哥教學 ","version":"Next","tagName":"h2"},{"title":"🐤 關於居民","type":0,"sectionRef":"#","url":"/docs/townHistory/inhabitant/about","content":"","keywords":"","version":"Next"},{"title":"居民​","type":1,"pageTitle":"🐤 關於居民","url":"/docs/townHistory/inhabitant/about#居民","content":"居民為小鎮的核心，所有事物都是圍繞著居民發生的 ","version":"Next","tagName":"h2"},{"title":"日常生活​","type":1,"pageTitle":"🐤 關於居民","url":"/docs/townHistory/inhabitant/about#日常生活","content":"","version":"Next","tagName":"h2"},{"title":"身分編號​","type":1,"pageTitle":"🐤 關於居民","url":"/docs/townHistory/inhabitant/about#身分編號","content":"居民的 id 是居民的識別編號 ","version":"Next","tagName":"h3"},{"title":"其他資訊​","type":1,"pageTitle":"🐤 關於居民","url":"/docs/townHistory/inhabitant/about#其他資訊","content":"飢餓: 當飢餓降到 0 時就會死翹翹 職業: 居民可到職業工會選擇職業 年齡: 每個居民入住時都會從 0 歲算起 零用錢: 目前手邊的現金，剛入住時小雞鎮會給予 500 津貼 ","version":"Next","tagName":"h3"},{"title":"🐤 居民模組","type":0,"sectionRef":"#","url":"/docs/townHistory/inhabitant/module","content":"","keywords":"","version":"Next"},{"title":"說明​","type":1,"pageTitle":"🐤 居民模組","url":"/docs/townHistory/inhabitant/module#說明","content":"居民模組會提供，新住民的註冊 ","version":"Next","tagName":"h2"},{"title":"資料表​","type":1,"pageTitle":"🐤 居民模組","url":"/docs/townHistory/inhabitant/module#資料表","content":"inhabitant 欄位\t型態\t說明id\tnvarchar(128)\t居民的生分證 name\tnvarchar(20)\t居民的姓名 hungry\tint\t等級為 0 ~ 10 occupation\tnvarchar(10)\t需要到職業工會選擇 age\tint\t年齡 居民入住時都會從 0 歲算起 money\tint\t目前手邊的現金 ban\tboolean\t驅除出境或是死掉的居民就會被座標住 create_time\tdateTime\t入住時間 update_time\tdateTime\t資料改動時間 update_user_id\tnvarchar(128)\t資料異動人 ","version":"Next","tagName":"h2"},{"title":"服務​","type":1,"pageTitle":"🐤 居民模組","url":"/docs/townHistory/inhabitant/module#服務","content":"由鎮長或相關人士來辦理居民的入鎮登記 ","version":"Next","tagName":"h2"},{"title":"🌦️ 關於自然環境","type":0,"sectionRef":"#","url":"/docs/townHistory/nature/about","content":"","keywords":"","version":"Next"},{"title":"時間​","type":1,"pageTitle":"🌦️ 關於自然環境","url":"/docs/townHistory/nature/about#時間","content":"小雞鎮的時間與現實生活是 1:1 的 ","version":"Next","tagName":"h2"},{"title":"天氣​","type":1,"pageTitle":"🌦️ 關於自然環境","url":"/docs/townHistory/nature/about#天氣","content":"小雞鎮每天都會有不同的天氣 ","version":"Next","tagName":"h2"},{"title":"自然資源​","type":1,"pageTitle":"🌦️ 關於自然環境","url":"/docs/townHistory/nature/about#自然資源","content":"小雞鎮富含許多豐富的天然資源，來供應鎮民的生活 ","version":"Next","tagName":"h2"},{"title":"🕰️ 時間模組","type":0,"sectionRef":"#","url":"/docs/townHistory/nature/clockModule","content":"","keywords":"","version":"Next"},{"title":"說明​","type":1,"pageTitle":"🕰️ 時間模組","url":"/docs/townHistory/nature/clockModule#說明","content":"小雞鎮需要一個時間服務，讓大家養成守時的習慣 ","version":"Next","tagName":"h2"},{"title":"服務​","type":1,"pageTitle":"🕰️ 時間模組","url":"/docs/townHistory/nature/clockModule#服務","content":"提供詢問時間服務 ","version":"Next","tagName":"h2"},{"title":"🐔 Entity Auto Load","type":0,"sectionRef":"#","url":"/docs/typeORM/entityAutoload","content":"","keywords":"","version":"Next"},{"title":"TypeORM 的 Entity​","type":1,"pageTitle":"🐔 Entity Auto Load","url":"/docs/typeORM/entityAutoload#typeorm-的-entity","content":"TypeORM 有兩種模式 自動載入: TypeORM 會自動搜尋需要註冊的檔案手動載入: 須由開發者決定應該要載入那些 Entity ","version":"Next","tagName":"h2"},{"title":"autoLoadEntities 設定​","type":1,"pageTitle":"🐔 Entity Auto Load","url":"/docs/typeORM/entityAutoload#autoloadentities-設定","content":"","version":"Next","tagName":"h2"},{"title":"app module import 設定​","type":1,"pageTitle":"🐔 Entity Auto Load","url":"/docs/typeORM/entityAutoload#app-module-import-設定","content":"在 TypeORM 的 migration 設定中有一個屬性 autoLoadEntities， 這屬性決定是否要自動載入 Entity src └─inhabitant │└─inhabitant.entity.ts │ └─app.controller.spec.ts │ └─app.controller.ts │ └─app.module.ts │ └─app.service.ts │ └─typeorm.migration.ts │ └─main.ts  TypeOrmModule.forRootAsync({ useFactory(configService: ConfigService) { const IS_DB_SSL_MODE = configService.getOrThrow&lt;boolean&gt;( 'IS_DB_SSL_MODE', false, ); return { ssl: IS_DB_SSL_MODE, // 是否要使用 ssl 連線，一般正式連線會啟用 extra: { ssl: IS_DB_SSL_MODE ? { rejectUnauthorized: false } : null, poolSize: 5, idleTimeoutMillis: 3600000, }, type: 'postgres', //連線資料庫的類型 url: configService.getOrThrow('DB_URI', ''), synchronize: false, //否自動同步 entity 到資料庫 table autoLoadEntities: true, //是否自動載入 Entity 到 forRoot TypeORM, }; }, inject: [ConfigService], }),  ","version":"Next","tagName":"h3"},{"title":"自動載入​","type":1,"pageTitle":"🐔 Entity Auto Load","url":"/docs/typeORM/entityAutoload#自動載入","content":"在自動載入模式下，需定義 Entity 檔案的命名規則， 在 entities 這屬性底下，指定 Entity 的檔案， 通常會將檔案定義成 xxx.entity.ts src └─inhabitant │└─inhabitant.entity.ts │ └─app.controller.spec.ts │ └─app.controller.ts │ └─app.module.ts │ └─app.service.ts │ └─typeorm.migration.ts │ └─main.ts  config(); const configService = new ConfigService(); const IS_DB_SSL_MODE = configService.getOrThrow&lt;boolean&gt;( 'IS_DB_SSL_MODE', false, ); export default new DataSource({ type: 'postgres', url: configService.get&lt;string&gt;('DB_URI', ''), ssl: IS_DB_SSL_MODE, extra: { ssl: IS_DB_SSL_MODE ? { rejectUnauthorized: false } : null, }, migrations: ['src/migrations/*.ts'], migrationsRun: true, entities: ['**/*.entity.ts'], });  ","version":"Next","tagName":"h3"},{"title":"手動載入​","type":1,"pageTitle":"🐔 Entity Auto Load","url":"/docs/typeORM/entityAutoload#手動載入","content":"在手動載入的模式下，開法者需要決定要載入那些 Entity src └─inhabitant │└─inhabitant.entity.ts │ └─app.controller.spec.ts │ └─app.controller.ts │ └─app.module.ts │ └─app.service.ts │ └─typeorm.migration.ts │ └─main.ts  config(); const configService = new ConfigService(); const IS_DB_SSL_MODE = configService.getOrThrow&lt;boolean&gt;( 'IS_DB_SSL_MODE', false, ); export default new DataSource({ type: 'postgres', url: configService.get&lt;string&gt;('DB_URI', ''), ssl: IS_DB_SSL_MODE, extra: { ssl: IS_DB_SSL_MODE ? { rejectUnauthorized: false } : null, }, migrations: ['src/migrations/*.ts'], migrationsRun: true, entities: [InhabitantEntity], });  ","version":"Next","tagName":"h3"},{"title":"使用方式​","type":1,"pageTitle":"🐔 Entity Auto Load","url":"/docs/typeORM/entityAutoload#使用方式","content":"如果要使用 Entity 需到該模組的 Module 去註冊 src └─inhabitant │└─inhabitant.entity.ts ││ │└─inhabitant.module.ts │ └─app.controller.spec.ts │ └─app.controller.ts │ └─app.module.ts │ └─app.service.ts │ └─typeorm.migration.ts │ └─main.ts  @Module({ imports: [TypeOrmModule.forFeature([InhabitantEntity])], controllers: [InhabitantController], providers: [ { provide: 'InhabitantServiceInterface', useClass: InhabitantService, }, { provide: 'InhabitantRepositoryInterface', useClass: InhabitantRepository, }, ], }) export class InhabitantModule {}   ","version":"Next","tagName":"h2"},{"title":"REF​","type":1,"pageTitle":"🐔 Entity Auto Load","url":"/docs/typeORM/entityAutoload#ref","content":"梁迪哥 教學 ","version":"Next","tagName":"h2"},{"title":"🐔 TypeORM 的 CRUD","type":0,"sectionRef":"#","url":"/docs/typeORM/aboutCrud","content":"","keywords":"","version":"Next"},{"title":"關於 CRUD​","type":1,"pageTitle":"🐔 TypeORM 的 CRUD","url":"/docs/typeORM/aboutCrud#關於-crud","content":"在整個 TypeORM 最核心的觀念就是 CRUD CRUD 則是一個縮寫，代表了以下四個基本操作： Create (新增)：在資料庫中新增記錄或資料Read (讀取)：從資料庫中讀取或搜尋記錄或資料Update (更新)：更新現有記錄或資料的內容Delete (刪除)：從資料庫中刪除現有的記錄或資料 ","version":"Next","tagName":"h2"},{"title":"CRUD 實作​","type":1,"pageTitle":"🐔 TypeORM 的 CRUD","url":"/docs/typeORM/aboutCrud#crud-實作","content":"","version":"Next","tagName":"h2"},{"title":"準備​","type":1,"pageTitle":"🐔 TypeORM 的 CRUD","url":"/docs/typeORM/aboutCrud#準備","content":"注入 Repository 與 DataSource constructor( private readonly dataSource: DataSource, @InjectRepository(InhabitantEntity) private readonly inhabitantDao: Repository&lt;InhabitantEntity&gt;, ) {}  定義 table name 與 schema因為在 CRUD 的過程都會用到這些，所以將他抽離出來做成私有變數，保持一致性  private readonly _tableName: string = 'inhabitant'; private readonly _schema: string[] = [ 'id', 'name', 'hungry', 'occupation', 'age', 'money', 'ban', 'create_time', 'update_time', 'update_user_id', ];  ","version":"Next","tagName":"h3"},{"title":"Read​","type":1,"pageTitle":"🐔 TypeORM 的 CRUD","url":"/docs/typeORM/aboutCrud#read","content":"搜尋分為兩種，一種是搜尋整張 table 的資料 一種是有條件的查詢 並且在查詢功能上都是使用 Repository&lt;InhabitantEntity&gt; 的物件 搜尋全部使用 find 查出來後會是一個 Array&lt;InhabitantEntity&gt;  async readAll(): Promise&lt;InhabitantDto[]&gt; { const result = await this.inhabitantDao.find(); return result.map((data) =&gt; ({ id: data.id, name: data.name, age: data.age, occupation: data.occupation, })); }  代條件查詢使用 fineOne並且加入 where 語句  async readById(id: string): Promise&lt;InhabitantDto&gt; { const result = await this.inhabitantDao.findOne({ where: { id: id, }, }); return { id: result.id, name: result.name, age: result.age, occupation: result.occupation, }; }  ","version":"Next","tagName":"h3"},{"title":"Create​","type":1,"pageTitle":"🐔 TypeORM 的 CRUD","url":"/docs/typeORM/aboutCrud#create","content":"建立需要透過 DataSource 這個物件來執行  async create(data: InhabitantEntity): Promise&lt;InhabitantDto&gt; { // 1. 先建立 dataSource 的物件 const queryBuilder = this.dataSource .getRepository(InhabitantEntity) .createQueryBuilder(this._tableName); //2. 將資料寫入 db const result = await queryBuilder .insert() // 插入資料庫操作 .into(InhabitantEntity) // 插入到 &quot;InhabitantEntity&quot; 資料表 .values([data]) // 插入的資料（data）值 .returning(this._schema) // 返回的資料模型或結構 .updateEntity(true) // 更新實體（true表示執行更新操作） .execute(); // 執行操作並獲取結果 const model = result.raw[0] as InhabitantEntity; return { id: model.id, name: model.name, age: model.age, occupation: model.occupation, }; }  ","version":"Next","tagName":"h3"},{"title":"Update​","type":1,"pageTitle":"🐔 TypeORM 的 CRUD","url":"/docs/typeORM/aboutCrud#update","content":"更新資料庫，分為兩種，一種是讓 ORM 自行去斷定是否要更新 另一種是指定這次要更新的欄位 讓 ORM 自行判斷  async update(data: InhabitantEntity): Promise&lt;InhabitantDto&gt; { // 1. 先建立 dataSource 的物件 const queryBuilder = this.dataSource .getRepository(InhabitantEntity) .createQueryBuilder(this._tableName); // 2. 將資料寫入 db（將資料更新到資料庫中） const result = await queryBuilder .update&lt;InhabitantEntity&gt;(InhabitantEntity, data) // 更新資料 .where(this._tableName + '.id = :id', { id }) // 指定更新條件（根據 id） .returning(this._schema) // 返回的資料模型或結構 .updateEntity(true) // 更新實體（true表示執行更新操作） .execute(); // 執行操作並獲取結果 const model = result.raw[0] as InhabitantEntity; return { id: model.id, name: model.name, age: model.age, occupation: model.occupation, }; }  指定更新欄位  async update( data: UpdateInhabitantDto, updateId: string, ): Promise&lt;InhabitantDto&gt; { // 1. 先建立 dataSource 的物件 const queryBuilder = this.dataSource .getRepository(InhabitantEntity) .createQueryBuilder(this._tableName); // 2. 將資料寫入 db（將資料更新到資料庫中） const result = await queryBuilder .update(this._tableName) // 指定要更新的資料表 .set({ name: data.name, // 設置新的名稱（使用 data.name） update_user_id: updateId, // 設置更新使用者的 ID（使用 updateId 變數） }) .where(this._tableName + '.id = :id', { updateId }) // 指定更新條件 .returning(this._schema) // 返回的資料模型或結構 .updateEntity(true) // 更新實體（true表示執行更新操作） .execute(); // 執行操作並獲取結果 const model = result.raw[0] as InhabitantEntity; return { id: model.id, name: model.name, age: model.age, occupation: model.occupation, }; }  ","version":"Next","tagName":"h3"},{"title":"Delete​","type":1,"pageTitle":"🐔 TypeORM 的 CRUD","url":"/docs/typeORM/aboutCrud#delete","content":"永久刪除資料庫的整筆資料  async deleteById(id: string): Promise&lt;InhabitantDto&gt; { // 1. 先建立 dataSource 的物件 const queryBuilder = this.dataSource .getRepository(InhabitantEntity) .createQueryBuilder(this._tableName); // 2. 將資料寫入 db（將資料更新到資料庫中） const result = await queryBuilder .delete() // 刪除資料 .where(this._tableName + '.id = :id', { updateId }) // 指定更新條件 .returning(this._schema) // 返回的資料模型或結構 .execute(); // 執行操作並獲取結果 const model = result.raw[0] as InhabitantEntity; return { id: model.id, name: model.name, age: model.age, occupation: model.occupation, }; }   ","version":"Next","tagName":"h3"},{"title":"REF​","type":1,"pageTitle":"🐔 TypeORM 的 CRUD","url":"/docs/typeORM/aboutCrud#ref","content":"梁迪哥 教學 ","version":"Next","tagName":"h2"},{"title":"🐔 使用 TypeORM","type":0,"sectionRef":"#","url":"/docs/typeORM/useTypeorm","content":"","keywords":"","version":"Next"},{"title":"關於​","type":1,"pageTitle":"🐔 使用 TypeORM","url":"/docs/typeORM/useTypeorm#關於","content":"TypeORM: 支援 Typescript 型別宣告的 Nodejs ORM 框架 ","version":"Next","tagName":"h2"},{"title":"DataSource​","type":1,"pageTitle":"🐔 使用 TypeORM","url":"/docs/typeORM/useTypeorm#datasource","content":"是一個用來管理與資料庫連線的重要元件，在應用程式啟動時建立連線池，在關閉應用程式時關閉連線池 在 Nestjs 應用程式中，這些工作都可以由元件管理器自動處理，無需手動設定 ","version":"Next","tagName":"h3"},{"title":"Migration​","type":1,"pageTitle":"🐔 使用 TypeORM","url":"/docs/typeORM/useTypeorm#migration","content":"Migration 預設如果 synchronized 設定成 true，就會自動更新資料表為當下 Entity 格式，適合用來做資料庫遷移 ","version":"Next","tagName":"h3"},{"title":"使用 TypeORM​","type":1,"pageTitle":"🐔 使用 TypeORM","url":"/docs/typeORM/useTypeorm#使用-typeorm","content":"","version":"Next","tagName":"h2"},{"title":"安裝套件​","type":1,"pageTitle":"🐔 使用 TypeORM","url":"/docs/typeORM/useTypeorm#安裝套件","content":"pnpm add @nestjs/config pnpm add @nestjs/typeorm typeorm pg pnpm add joi pnpm add dotenv  ","version":"Next","tagName":"h3"},{"title":"設定資料庫連線​","type":1,"pageTitle":"🐔 使用 TypeORM","url":"/docs/typeORM/useTypeorm#設定資料庫連線","content":"先 import 需要的依賴 import { ConfigModule, ConfigService } from '@nestjs/config'; import { TypeOrmModule } from '@nestjs/typeorm'; import * as Joi from 'joi';  於 app.module.ts 設定連線 import { Module } from '@nestjs/common'; import { AppController } from './app.controller'; import { AppService } from './app.service'; import { ConfigModule, ConfigService } from '@nestjs/config'; import { TypeOrmModule } from '@nestjs/typeorm'; import * as Joi from 'joi'; @Module({ imports: [ ConfigModule.forRoot({ isGlobal: true, validationSchema: Joi.object({ DB_URI: Joi.string().required(), IS_DB_SSL_MODE: Joi.boolean().required(), }), }), TypeOrmModule.forRootAsync({ useFactory(configService: ConfigService) { const IS_DB_SSL_MODE = configService.getOrThrow&lt;boolean&gt;( 'IS_DB_SSL_MODE', false, ); return { ssl: IS_DB_SSL_MODE, // 是否要使用 ssl 連線，一般正式連線會啟用 extra: { ssl: IS_DB_SSL_MODE ? { rejectUnauthorized: false } : null, poolSize: 5, idleTimeoutMillis: 3600000, }, type: 'postgres',//連線資料庫的類型 url: configService.getOrThrow('DB_URI', ''), synchronize: false,//否自動同步 entity 到資料庫 table autoLoadEntity: true//是否自動載入 Entity 到 forRoot TypeORM }; }, inject: [ConfigService], }), ], controllers: [AppController], providers: [AppService], }) export class AppModule { }  ","version":"Next","tagName":"h3"},{"title":"加入 Entity​","type":1,"pageTitle":"🐔 使用 TypeORM","url":"/docs/typeORM/useTypeorm#加入-entity","content":"於 inhabitant 目錄底下，建立一個檔案為 inhabitant.entity.ts src └─inhabitant │└─inhabitant.entity.ts │ └─app.controller.spec.ts │ └─app.controller.ts │ └─app.module.ts │ └─app.service.ts │ └─main.ts  import { Column, CreateDateColumn, Entity, PrimaryGeneratedColumn, UpdateDateColumn, } from 'typeorm'; @Entity('inhabitant', { schema: 'public' }) export class InhabitantEntity { @PrimaryGeneratedColumn('uuid') id: string; @Column({ name: 'idCard', type: 'nvarchar', length: 128 }) idCard: string; @Column({ name: 'name', type: 'nvarchar', length: 20 }) name: string; @Column({ name: 'hungry', type: 'int' }) hungry: number; @Column({ name: 'occupation', type: 'nvarchar', length: 10 }) occupation: string; @Column({ name: 'age', type: 'int' }) age: number; @Column({ name: 'money', type: 'int' }) money: number; @Column({ name: 'ban', type: 'boolean' }) ban: boolean; @CreateDateColumn({ name: 'create_time', type: 'datetime' }) create_time: Date; @UpdateDateColumn({ name: 'update_time', type: 'timestamp without time zone' }) update_time: Date; @Column({ name: 'update_user_id', type: 'nvarchar', length: 128 }) update_user_id: string; }  註冊 Entity nest generate module inhabitant  ","version":"Next","tagName":"h3"},{"title":"設定資料庫轉移​","type":1,"pageTitle":"🐔 使用 TypeORM","url":"/docs/typeORM/useTypeorm#設定資料庫轉移","content":"新增 typeorm.migration.ts src └─inhabitant │└─inhabitant.entity.ts │ └─app.controller.spec.ts │ └─app.controller.ts │ └─app.module.ts │ └─app.service.ts │ └─typeorm.migration.ts │ └─main.ts  import { ConfigService } from '@nestjs/config'; import { config } from 'dotenv'; import { DataSource } from 'typeorm'; config(); const configService = new ConfigService(); const IS_DB_SSL_MODE = configService.getOrThrow&lt;boolean&gt;( 'IS_DB_SSL_MODE', false, ); export default new DataSource({ type: 'postgres', url: configService.get&lt;string&gt;('DB_URI', ''), ssl: IS_DB_SSL_MODE, extra: { ssl: IS_DB_SSL_MODE ? { rejectUnauthorized: false } : null, }, migrations: ['src/migrations/*.ts'], migrationsRun: true, entities: ['**/*.entity.ts'], });  新增 .env src └─inhabitant │└─inhabitant.entity.ts │ └─app.controller.spec.ts │ └─app.controller.ts │ └─app.module.ts │ └─app.service.ts │ └─typeorm.migration.ts │ └─.env │ └─main.ts  DB_URI=postgresql://${db_username}:${db_password}@${db_hostname}:${db_port}/${db_name}  ","version":"Next","tagName":"h3"},{"title":"新增 script​","type":1,"pageTitle":"🐔 使用 TypeORM","url":"/docs/typeORM/useTypeorm#新增-script","content":"於 package.js 新增 script &quot;typeorm&quot;: &quot;ts-node ./node_modules/typeorm/cli&quot;, &quot;schema:sync&quot;: &quot;pnpm run typeorm schema:sync -d src/typeorm.migration.ts&quot;, &quot;schema:drop&quot;: &quot;pnpm run typeorm schema:drop -d src/typeorm.migration.ts&quot;, &quot;schema:log&quot;: &quot;pnpm run typeorm schema:log -d src/typeorm.migration.ts&quot;, &quot;typeorm:show&quot;: &quot;pnpm run typeorm migration:show -d src/typeorm.migration.ts&quot;, &quot;typeorm:run-migrations&quot;: &quot;pnpm run typeorm -- migration:run -d src/typeorm.migration.ts&quot;, &quot;typeorm:create-migration&quot;: &quot;npm run typeorm -- migration:create src/migrations/$npm_config_name&quot;, &quot;typeorm:generate-migration&quot;: &quot;npm run typeorm -- migration:generate -d src/typeorm.migration.ts src/migrations/$npm_config_name&quot;, &quot;typeorm:revert-migration&quot;: &quot;pnpm run typeorm migration:revert -d src/typeorm.migration.ts&quot;  在 windows 底下 &quot;typeorm:create-migration&quot;: &quot;npm run typeorm -- migration:create src/migrations/$npm_config_name&quot;,  需換成 &quot;typeorm:create-migration&quot;: &quot;npm run typeorm -- migration:create src/migrations/%npm_config_name%&quot;,  ","version":"Next","tagName":"h3"},{"title":"新增 migration​","type":1,"pageTitle":"🐔 使用 TypeORM","url":"/docs/typeORM/useTypeorm#新增-migration","content":"npm run typeorm:create-migration --name=INHABITANT  import { MigrationInterface, QueryRunner, Table, TableColumn, TableForeignKey } from &quot;typeorm&quot;; export class INHABITANT1695957121944 implements MigrationInterface { public async up(queryRunner: QueryRunner): Promise&lt;void&gt; { await queryRunner.createTable(new Table({ name: &quot;inhabitant&quot;, schema: &quot;public&quot;, columns: [ { name: &quot;id&quot;, type: &quot;uuid&quot;, isPrimary: true, generationStrategy: &quot;uuid&quot;, default: &quot;uuid_generate_v4()&quot;, }, { name: &quot;idCard&quot;, type: &quot;nvarchar&quot;, length: &quot;128&quot;, }, { name: &quot;name&quot;, type: &quot;nvarchar&quot;, length: &quot;20&quot;, }, { name: &quot;hungry&quot;, type: &quot;int&quot;, }, { name: &quot;occupation&quot;, type: &quot;nvarchar&quot;, length: &quot;10&quot;, }, { name: &quot;age&quot;, type: &quot;int&quot;, }, { name: &quot;money&quot;, type: &quot;int&quot;, }, { name: &quot;ban&quot;, type: &quot;boolean&quot;, }, { name: &quot;create_time&quot;, type: &quot;datetime&quot;, }, { name: &quot;update_time&quot;, type: &quot;timestamp without time zone&quot;, }, { name: &quot;update_user_id&quot;, type: &quot;nvarchar&quot;, length: &quot;128&quot;, }, ], }), true); } public async down(queryRunner: QueryRunner): Promise&lt;void&gt; { await queryRunner.dropTable(&quot;inhabitant&quot;, true, true, true); } }  ","version":"Next","tagName":"h3"},{"title":"新增 schema​","type":1,"pageTitle":"🐔 使用 TypeORM","url":"/docs/typeORM/useTypeorm#新增-schema","content":"pnpm run typeorm:run-migrations  此時就能看到資料庫長出表格了 ","version":"Next","tagName":"h3"},{"title":"REF​","type":1,"pageTitle":"🐔 使用 TypeORM","url":"/docs/typeORM/useTypeorm#ref","content":"副鎮長-梁迪哥 教學 ","version":"Next","tagName":"h2"}]